#!/usr/bin/env bash
# shellcheck disable=SC2162 # Allow read without -r for backward compatibility
# dbh - Interactive MySQL client with slash commands, shell access, and direct SQL
# Features:
# - Database/table navigation and exploration with /commands
# - Interactive menus for selecting databases, tables, and columns
# - Tabular output with paging for wide results
# - Shell access with ! prefix
# - Direct SQL execution without prefixes
set -eEuo pipefail +o histexpand
shopt -s extglob globstar checkwinsize nocasematch # nocasematch for command parsing

# --- History Setup ---
unset HISTFILE # Use default ~/.bash_history or respect HISTFILE if already set
HISTSIZE=1000
HISTFILESIZE=2000
shopt -s histappend # Append to history, don't overwrite

readonly VERSION='3.0.7' # Security fixes and code improvements

# Get script path and extract directory/program name
PRG0=$(readlink -en -- "$0") || { echo "ERROR: Could not resolve script path"; exit 1; }
readonly PRG0
readonly PRGDIR="${PRG0%/*}" 
readonly PRG="${PRG0##*/}"

# --- Messaging Functions ---
declare -ix VERBOSE=1 DEBUG=0
declare -- RED='' YELLOW='' GREEN='' CYAN='' NOCOLOR=''
if [[ -t 2 ]]; then
  RED=$'\e[1;31m' YELLOW=$'\e[1;33m' GREEN=$'\e[1;32m' CYAN=$'\e[1;36m' NOCOLOR=$'\e[0m'
fi

_message() { # type (1=info, 2=warn, 3=error, 4=success, 5=debug), prefix, text
  local -i type=$1 use_stderr=0
  local prefix="$3" text="$4" color="$NOCOLOR"
  case $type in
    2) color="$YELLOW"; use_stderr=1;; 3) color="$RED"; use_stderr=1;;
    4) color="$GREEN";; 5) [[ $DEBUG -eq 0 ]] && return 0; color="$CYAN"; use_stderr=1;;
    *) color="$NOCOLOR";;
  esac
  if (( type > 1 || VERBOSE > 0 )); then
    printf '%s%s%s%s\n' "$color" "$prefix" "$text" "$NOCOLOR" >&"$((use_stderr + 1))"
  fi
  return 0 # Messaging itself should not cause script exit via set -e
}
info()    { _message 1 "" "" "$*"; }
warn()    { _message 2 "" "WARN: " "$*"; }
error()   { _message 3 "" "ERROR: " "$*"; }
success() { _message 4 "" "OK: " "$*"; }
debug()   { _message 5 "" "DEBUG: " "$*"; }
die()     { _message 3 "" "FATAL: " "${2:-"Unknown error"}"; exit "${1:-1}"; }
# --- End Messaging ---

# --- Standard Utility Overrides/Helpers ---
# Use absolute paths to prevent command injection
grep() { command /usr/bin/grep "$@"; }
find() { command /usr/bin/find "$@"; }
sed() { command /usr/bin/sed "$@"; }
declare -fx grep find sed
# --- End Utility Overrides ---

# --- Script Helpers ---
noarg() { if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then die 2 "Missing argument for option '$1'"; fi; true; }
decp() { declare -p "$@" | sed 's/^declare -[a-zA-Z-]* //'; }
trim() { local v="$*"; v="${v#"${v%%[![:blank:]]*}"}"; echo -n "${v%"${v##*[![:blank:]]}"}"; }

# Function to safely quote SQL identifiers
quote_ident() { 
  local ident="$1"
  # Double backticks within identifiers
  ident="${ident//\`/\`\`}"
  echo "\`$ident\`"
}

# Function to safely escape values for SQL WHERE clauses
escape_sql_value() {
  local value="$1"
  # Replace single quotes with two single quotes (SQL standard escaping)
  value="${value//\'/\'\'}"
  echo "'$value'"
}

# Create random temp file with secure permissions
create_secure_tempfile() {
  local prefix="$1"
  local tmp_dir="${TMPDIR:-/tmp}"
  [[ -d "$tmp_dir" && -w "$tmp_dir" ]] || tmp_dir="/tmp"
  
  # Create temp file with restrictive permissions
  local temp_file
  temp_file=$(TMPDIR="$tmp_dir" mktemp "${prefix}.XXXXXXXXXX")
  chmod 0600 "$temp_file"
  echo "$temp_file"
}

# MySQL execution wrapper with improved security
mysql_exec() {
  # Ensure variables are local and initialized
  local output="" error="" exit_code=1 # Default to error
  local out_file err_file

  debug "Executing MySQL command with profile '$PROFILE': $*"
  
  # Create secure temp files
  out_file=$(create_secure_tempfile "${PRG}.out")
  err_file=$(create_secure_tempfile "${PRG}.err")
  
  # Ensure cleanup even if function errors out or script exits
  trap 'rm -f "$out_file" "$err_file"; trap - RETURN' RETURN

  debug "Capturing stdout>'$out_file', stderr>'$err_file'"
  # Execute command directly, using the PROFILE variable from the main scope
  mysql --defaults-file="$PROFILE" --no-auto-rehash "$@" >"$out_file" 2>"$err_file"
  exit_code=$?
  debug "MySQL command finished, exit_code=$exit_code"

  # Read contents back
  output=$(< "$out_file")
  error=$(< "$err_file")

  # Cleanup handled by trap RETURN
  rm -f "$out_file" "$err_file"
  trap - RETURN # Disable trap for this function before normal return

  debug "MySQL exit code: $exit_code"
  [[ -n "$error" ]] && debug "MySQL stderr: $error"
  [[ -n "$output" ]] && echo "$output" # Print captured stdout

  # Handle functional errors based on exit code and stderr
  if (( exit_code != 0 )); then
    error "MySQL command failed (Exit Code: $exit_code)" # error() returns 0
    local mysql_err_msg
    mysql_err_msg=$(echo "$error" | sed -n 's/^.*ERROR[[:space:]]*[0-9]*[[:space:]]*(\(.*\)).*:[[:space:]]*\(.*\)/\1: \2/p' | head -n 1)
    if [[ -n "$mysql_err_msg" ]]; then 
      error "MySQL Error: $mysql_err_msg"
    elif [[ -n "$error" ]]; then 
      error "MySQL Raw Error Output: ${error}"
    fi
    return $exit_code # Return non-zero status code
  elif [[ -n "$error" ]]; then 
    warn "MySQL produced warnings: ${error}"
  fi
  # If exit_code was 0, return 0
  return 0
}

# MySQL execution - Direct to TTY for display (used by /select)
mysql_run_display() {
  # Expects DB name as $1, then mysql arguments (like -e "SQL")
  local db_name="$1"
  shift # Remove db_name from args list

  debug "Executing MySQL display command with profile '$PROFILE' for DB '$db_name': $*"
  
  # Execute directly, letting output go to terminal
  mysql --defaults-file="$PROFILE" --no-auto-rehash "$db_name" "$@"
  local exit_code=$?
  debug "MySQL display command finished, exit_code=$exit_code"

  if (( exit_code != 0 )); then
    # Error messages likely already printed by mysql to stderr
    error "MySQL display command failed (Exit Code: $exit_code)" # error() returns 0
    return $exit_code # Return non-zero status
  fi
  
  return 0 # Success
}
# Shell execution - Launch interactive shell or run shell command
handle_shell_command() {
  local cmd="$*"
  
  # Save terminal state
  local saved_stty
  saved_stty=$(stty -g 2>/dev/null) || true
  
  info "Launching shell $([[ -n "$cmd" ]] && echo "command: $cmd" || echo "session")..."
  
  if [[ -n "$cmd" ]]; then
    # Execute specific command
    bash -c "$cmd"
  else
    # Launch interactive shell
    if [[ -n "$SHELL" ]]; then
      "$SHELL"
    else
      bash
    fi
  fi
  
  local exit_code=$?
  
  # Restore terminal state
  stty "$saved_stty" 2>/dev/null || true
  clear
  
  if (( exit_code == 0 )); then
    info "Shell session completed. Returned to $PRG."
  else
    warn "Shell exited with status $exit_code. Returned to $PRG."
  fi
  
  return 0
}

# --- End Helpers & Command Handlers ---

# --- Global Variables & State Management ---
declare -x Profile_Default="$HOME/.mylocalhost.cnf"
declare -xg PROFILE='' Database='' DataTable=''
# State for building SELECT queries
declare -ga SelectedColumns=('*') # Array of column names, default '*'
declare -g WhereClause="" OrderClause="" OrderDirection="ASC" LimitClause="100"
declare -g PromptPrefix="[dbh]"
# --- End Globals ---

# --- Cleanup ---
xcleanup() {
  local -i exitcode=${1:-$?}
  
  # Restore cursor if running in terminal
  [[ -t 0 ]] && printf '\e[?25h' >&2
  
  # Clean up any remaining temp files with more secure pattern
  find "${TMPDIR:-/tmp}" -maxdepth 1 -type f -name "${PRG}.*.????????" -user "$(id -u)" -delete 2>/dev/null || true
  
  # Normal exit
  exit "$exitcode"
}

# Set trap for cleanup on exit
trap 'xcleanup $?' EXIT TERM INT HUP
# --- End Cleanup ---

usage() {
  cat <<EOT
$PRG v$VERSION - Interactive MySQL client with slash commands, shell access, and direct SQL

Usage:
  $PRG [Options] [database [table]]

  database  Optional: Initial database to connect to
  table     Optional: Initial table to select

Options:
  -p, --profile PROFILE  MySQL config file (Default: $Profile_Default)
  -v, --verbose   Increase verbosity
  -q, --quiet     Suppress non-error messages
  -V, --version   Print version and exit
  -h, --help      Display this help

Command Types:
  /command          Slash commands for database operations
  !command          Shell commands (!alone for interactive shell)
  SQL               Direct SQL when not starting with / or !

Database Navigation:
  /help             Show available commands
  /databases        List & select database via menu
  /database <db>    Directly select database
  /tables           List & select table via menu
  /table <name>     Directly select table
  /.. | /0 | /back  Go back one level (Table->DB->Exit)
  /q | /quit | /exit Exit the shell

Query Building:
  /columns [c1,c2]  Set columns (shows multi-select menu)
  /where [clause]   Set WHERE clause
  /order [col(s)]   Set ORDER BY columns
  /asc | /desc      Set ORDER BY direction
  /limit [num]      Set LIMIT
  /select           Execute query with current state
  /state            Show query state

Table Operations:
  /describe         Show table structure 
  /structure [v]    Detailed column info (v=vertical)
  /status           Show table status
  /create           Show CREATE statement
  /count            Show row count
  /sql <SQL>        Execute arbitrary SQL
  /prompt           Open MySQL prompt

Shell Access:
  !                 Interactive shell (returns to dbh)
  !command          Execute shell command
  !shell command    Alternative syntax

Examples:
  $PRG mydb users # Start in mydb.users
  [dbh:mydb:users]> /columns id,name,email
  [dbh:mydb:users]> /where active=1
  [dbh:mydb:users]> /select
  [dbh:mydb:users]> SELECT * FROM users WHERE id=123
  [dbh:mydb:users]> ! ls -la
  [dbh:mydb:users]> /q

EOT
  (($#)) && exit "${1:-0}"
  return 0
}

#=============================================================================
# Database and Table Context Management
# Handles selection, validation, and context switching
#=============================================================================

# Sets the database context, clears table, updates prompt
set_database_context() {
  local db_name="$1"
  local db_check_status=0
  
  # Safely quote database name to prevent SQL injection
  local quoted_db_name
  quoted_db_name=$(quote_ident "$db_name")
  
  # Check if database exists and is accessible
  mysql_exec -e "USE ${quoted_db_name};" >/dev/null 2>&1 || db_check_status=$?
  
  if (( db_check_status == 0 )); then
    # Store previous database to check if it changed
    local previous_db="$Database"
    
    # Set new database context
    Database="$db_name"
    DataTable="" 
    PromptPrefix="[dbh:$Database]"
    success "Using database '$Database'."
    
    # If database has changed, show tables menu
    if [[ "$previous_db" != "$Database" ]]; then
      info "Showing available tables in '$Database'..."
      # Show tables but don't return error if user cancels
      handle_cmd_tables || true
    fi
    
    return 0
  else
    Database=""
    DataTable=""
    PromptPrefix="[dbh]"
    error "Cannot use database '$db_name'. Does it exist and do you have access rights?"
    return 1
  fi
}

# Sets the table context, updates prompt
set_table_context() {
  local table_name="$1"
  
  # Verify database context
  if [[ -z "$Database" ]]; then
    error "No database selected. Use /database first."
    return 1
  fi
  
  # Safe escape for LIKE pattern
  local escaped_table_name
  escaped_table_name=$(escape_sql_value "$table_name")
  escaped_table_name=${escaped_table_name//\%/\\%} # Escape % in LIKE
  escaped_table_name=${escaped_table_name//_/\\_} # Escape _ in LIKE
  
  # Remove the outer quotes and readd them for LIKE syntax
  escaped_table_name="${escaped_table_name:1:-1}"
  
  local table_check_status=0
  local check_output
  
  # Check if table exists
  check_output=$(mysql_exec "$Database" -Nse "SELECT table_name FROM information_schema.tables WHERE table_schema = $(escape_sql_value "$Database") AND table_name = $(escape_sql_value "$table_name") LIMIT 1;") || table_check_status=$?
  
  if (( table_check_status != 0 )) || [[ -z "$check_output" ]]; then
    error "Table '$table_name' not found in database '$Database'."
    return 1
  else
    DataTable="$table_name"
    PromptPrefix="[dbh:$Database:$DataTable]"
    success "Using table '$DataTable'."
    return 0
  fi
}

# Go back one context level
go_back_context() {
  if [[ -n "$DataTable" ]]; then DataTable=""; PromptPrefix="[dbh:$Database]"; info "Returned to database '$Database'."
  elif [[ -n "$Database" ]]; then Database=""; PromptPrefix="[dbh]"; info "Returned to top level."
  else info "Already at the top level. Use /q to quit."; fi
  return 0
}

# Display current SELECT state
show_select_state() {
  info "--- Current SELECT State ---"
  info " Database: ${Database:-<None>}"; info " Table:  ${DataTable:-<None>}"
  local cols_display="${SelectedColumns[*]}"
  [[ "$cols_display" == "*" ]] || cols_display=$(IFS=,; echo "${SelectedColumns[*]}")
  info " Columns: $cols_display"; info " WHERE:   ${WhereClause:-<None>}"
  info " ORDER BY: ${OrderClause:-<None>} $OrderDirection"; info " LIMIT:   ${LimitClause:-<None>}"
  info "----------------------------"
  return 0
}

#=============================================================================
# Interactive Command Handlers
# Processes /commands, !shell commands, and direct SQL
#=============================================================================

handle_cmd_help() {
  info "---------------- $PRG v$VERSION Help ----------------"
  info " Context: $PromptPrefix"
  
  # Command Type Summary
  info " Command Types:"
  info "  /command          Database operations"
  info "  !command          Shell commands (!alone for interactive shell)"
  info "  SQL               Direct SQL input (when not starting with / or !)"
  
  # Database Navigation
  info " Database Navigation:"
  info "  /databases        List & select database"
  info "  /database <db>    Select database directly"
  info "  /tables           List & select table"
  info "  /table <tbl>      Select table directly"
  
  # Query Building
  info " Query Building:"
  info "  /columns [cols]   Set columns (Current: $(IFS=,; echo "${SelectedColumns[*]}"))"
  info "  /where [clause]   Set WHERE clause (Current: ${WhereClause:-<None>})"
  info "  /order [cols]     Set ORDER BY (Current: ${OrderClause:-<None>})"
  info "  /asc | /desc      Set direction (Current: $OrderDirection)"
  info "  /limit [num]      Set LIMIT (Current: ${LimitClause:-<None>})"
  info "  /select           Execute query with current settings"
  info "  /state            Show current query state"
  
  # Table Operations
  info " Table Operations:"
  if [[ -n "$DataTable" ]]; then
    info "  /describe         Structure of '$DataTable'"
    info "  /structure [v]    Detailed columns (v=vertical)"
    info "  /status           Status for '$DataTable'"
    info "  /create           CREATE TABLE statement"
    info "  /count            Row count"
  else
    info "  /describe         Table structure (requires table)"
    info "  /structure [v]    Detailed columns (requires table)"
    info "  /status           Table status (requires table)"
    info "  /create           CREATE TABLE statement (requires table)"
    info "  /count            Row count (requires table)"
  fi
  
  # General Operations
  info " General & SQL:"
  if [[ -n "$Database" ]]; then
    info "  /sql <SQL>        Execute SQL in '$Database'"
    info "  /prompt           MySQL prompt for '$Database'"
    info "  <SQL>             Direct SQL (no prefix needed)"
  else
    info "  /sql <SQL>        Execute SQL (requires database)"
    info "  /prompt           MySQL prompt (requires database)"
    info "  <SQL>             Direct SQL (requires database)"
  fi
  
  # Shell and Navigation
  info " Shell & Navigation:"
  info "  !                 Interactive shell"
  info "  !command          Execute shell command"
  info "  /.. | /0 | /back  Go back one level"
  info "  /q | /quit | /exit Exit $PRG"
  info "  /help             Show this help"
  
  info "---------------------------------------------------------------"
  return 0
}

handle_cmd_databases() {
  local db REPLY PS3
  local -a dbs
  local db_list_output
  
  # Get list of databases securely
  db_list_output=$(mysql_exec -Nse "SHOW DATABASES;" | sort -i) || { 
    warn "Could not retrieve databases."
    return 1
  }
  
  mapfile -t dbs <<< "$db_list_output"
  if [[ -z "${dbs[*]}" ]]; then 
    info "No databases found (or access denied)."
    return 1
  fi
  
  PS3="$PromptPrefix Select Database (0=cancel, ?=help): "
  echo
  tabs 8
  
  select db in "${dbs[@]}"; do
    REPLY=$(trim "$REPLY")
    case "$REPLY" in 
      q|quit|exit) 
        # Return to main loop instead of exiting program
        info "Database selection cancelled."
        db=''
        break 
        ;;
      0|back) 
        db=''
        break 
        ;;
      \?) 
        handle_cmd_help
        PS3="$PromptPrefix Select Database (0=cancel, ?=help): "
        continue 
        ;;
      *) 
        if [[ -z "$db" && -n "$REPLY" ]]; then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        [[ -n "$db" ]] && break
        ;;
    esac
  done
  
  tabs -8
  
  # Only attempt to set context if a selection was made
  if [[ -n "$db" ]]; then
    set_database_context "$db" || return 1
  else
    return 0  # Return success even when cancelled
  fi
  
  return 0
}

handle_cmd_database() {
  local db_name="$1"; [[ -z "$db_name" ]] && { error "Usage: /database <database_name>"; return 1; }
  set_database_context "$db_name"; return $?
}

handle_cmd_tables() {
  if [[ -z "$Database" ]]; then
    error "No database selected. Use /database first."
    return 1
  fi
  
  local tbl REPLY PS3
  local -a tables
  local table_list_output
  
  # Get list of tables securely
  table_list_output=$(mysql_exec "$Database" -Nse "SHOW TABLES;" | sort -i) || { 
    warn "Could not retrieve tables for '$Database'."
    return 1
  }
  
  mapfile -t tables <<< "$table_list_output"
  if [[ -z "${tables[*]}" ]]; then 
    info "No tables found in '$Database'."
    return 1
  fi
  
  PS3="$PromptPrefix Select Table (0=cancel, ?=help): "
  echo
  tabs 8
  
  select tbl in "${tables[@]}"; do
    REPLY=$(trim "$REPLY")
    case "$REPLY" in 
      q|quit|exit) 
        # Return to main loop instead of exiting program
        info "Table selection cancelled."
        tbl=''
        break 
        ;;
      0|back) 
        tbl=''
        break 
        ;;
      \?) 
        handle_cmd_help
        PS3="$PromptPrefix Select Table (0=cancel, ?=help): "
        continue 
        ;;
      *) 
        if [[ -z "$tbl" && -n "$REPLY" ]]; then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        [[ -n "$tbl" ]] && break
        ;;
    esac
  done
  
  tabs -8
  
  # Only attempt to set context if a selection was made
  if [[ -n "$tbl" ]]; then
    set_table_context "$tbl" || return 1
  else
    return 0  # Return success even when cancelled
  fi
  
  return 0
}

handle_cmd_table() {
  local table_name="$1"; [[ -z "$Database" ]] && { error "No database selected. Use /database first."; return 1; }
  [[ -z "$table_name" ]] && { error "Usage: /table <table_name>"; return 1; }
  set_table_context "$table_name"; return $?
}

handle_cmd_columns() {
  # First, verify we have a database and table selected
  if [[ -z "$Database" ]]; then
    error "No database selected. Use /database first."
    return 1
  fi
  
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  # Handle direct input from arguments if provided
  local cols_str="$*"
  if [[ -n "$cols_str" ]]; then
    # Process manually specified columns
    if [[ "$cols_str" == "*" ]]; then
      # Simple case: select all columns
      SelectedColumns=('*')
      info "Columns set to: *"
    else
      # Parse comma-separated list
      local temp_cols=()
      local i col
      
      # Split by comma, removing spaces
      IFS=',' read -r -a temp_cols <<< "${cols_str//[[:space:]]/}"
      
      # Trim each column
      for i in "${!temp_cols[@]}"; do
        temp_cols[i]=$(trim "${temp_cols[i]}")
      done
      
      # Filter empty entries
      SelectedColumns=()
      for col in "${temp_cols[@]}"; do
        [[ -n "$col" ]] && SelectedColumns+=("$col")
      done
      
      # Check if we have any valid columns
      if ((${#SelectedColumns[@]} == 0)); then
        error "Invalid column input. Setting back to *."
        SelectedColumns=('*')
        return 1
      fi
      
      info "Columns set to: $(IFS=,; echo "${SelectedColumns[*]}")"
    fi
    
    show_select_state
    return 0
  fi
  
  # Show interactive multi-select menu for columns
  # First, get column list from the table
  local column_list_output
  local -a available_columns
  
  # Get column names from the table
  column_list_output=$(mysql_exec "$Database" -Nse "SHOW COLUMNS FROM $(quote_ident "$DataTable") WHERE 1;") || { 
    error "Could not retrieve columns for '$Database.$DataTable'."
    return 1
  }
  
  # Extract just the column names (first column of output)
  column_list_output=$(echo "$column_list_output" | awk '{print $1}')
  
  # Convert to array
  mapfile -t available_columns <<< "$column_list_output"
  
  if [[ -z "${available_columns[*]}" ]]; then 
    error "No columns found in table '$DataTable'."
    return 1
  fi
  
  # Add "* (All columns)" as the first option
  available_columns=("* (All columns)" "${available_columns[@]}")
  
  # Display selection menu
  local PS3 col selected_indices=() selected_columns=()
  PS3="$PromptPrefix Select columns (multiple allowed, 0=done, q=cancel, ?=help): "
  
  echo "Current selection: $(IFS=,; echo "${SelectedColumns[*]}")"
  echo "Available columns in $Database.$DataTable:"
  tabs 8
  
  # Interactive selection loop
  while true; do
    # Display the menu with numbers
    echo
    for i in "${!available_columns[@]}"; do
      local mark=" "
      # Check if this column is already selected
      for sel in "${selected_indices[@]}"; do
        if [[ "$sel" == "$i" ]]; then
          mark="X"
          break
        fi
      done
      printf "%3d. [%s] %s\n" "$((i+1))" "$mark" "${available_columns[$i]}"
    done
    
    # Get user selection
    read -p "$PS3" REPLY
    REPLY=$(trim "$REPLY")
    
    case "$REPLY" in
      q|quit|exit) 
        info "Column selection cancelled."
        tabs -8
        return 1 
        ;;
      0|done) 
        break 
        ;;
      \?) 
        echo "Use numbers to select columns, multiple selections allowed."
        echo "Enter 0 or 'done' when finished, q to cancel."
        continue 
        ;;
      [0-9]*) 
        # Convert to zero-based index
        local idx=$((REPLY-1))
        if [[ $idx -lt 0 || $idx -ge ${#available_columns[@]} ]]; then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        # Check if this index is already selected
        local found=0
        for i in "${!selected_indices[@]}"; do
          if [[ "${selected_indices[$i]}" == "$idx" ]]; then
            # Remove from selection (toggle)
            unset 'selected_indices[$i]'
            found=1
            info "Removed ${available_columns[$idx]} from selection"
            # Re-index the array
            selected_indices=("${selected_indices[@]}")
            break
          fi
        done
        
        if [[ $found -eq 0 ]]; then
          # Special case for "* (All columns)" - clear other selections
          if [[ $idx -eq 0 ]]; then
            selected_indices=(0)
            info "Selected all columns (*)"
          else
            # If we have "*" and adding a specific column, remove the "*"
            if [[ " ${selected_indices[*]} " == *" 0 "* ]]; then
              selected_indices=()
            fi
            # Add to selection
            selected_indices+=("$idx")
            info "Added ${available_columns[$idx]} to selection"
          fi
        fi
        ;;
      *) 
        warn "Invalid input: $REPLY"
        ;;
    esac
  done
  
  tabs -8
  
  # No selection means select all columns
  if [[ ${#selected_indices[@]} -eq 0 ]]; then
    SelectedColumns=('*')
    info "No columns selected, defaulting to all columns (*)"
  else
    # Process the selections into actual column names
    SelectedColumns=()
    for idx in "${selected_indices[@]}"; do
      if [[ $idx -eq 0 ]]; then
        # Special case for "* (All columns)"
        SelectedColumns=('*')
        break
      else
        SelectedColumns+=("${available_columns[$idx]}")
      fi
    done
  fi
  
  # Show final selection
  if [[ "${SelectedColumns[*]}" == "*" ]]; then
    info "Columns set to: * (All columns)"
  else
    info "Columns set to: $(IFS=,; echo "${SelectedColumns[*]}")"
  fi
  
  show_select_state
  return 0
}

handle_cmd_where() {
  local where_input="$*"; if [[ $# -eq 0 ]]; then read -e -p "WHERE clause (blank to clear): " -i "$WhereClause" where_input; where_input=$(trim "$where_input"); fi
  WhereClause="$where_input"; info "WHERE clause set to: ${WhereClause:-<None>}"; show_select_state; return 0
}

handle_cmd_order() {
  local order_input="$*"; if [[ $# -eq 0 ]]; then read -e -p "ORDER BY column(s) (blank to clear): " -i "$OrderClause" order_input; order_input=$(trim "$order_input"); fi
  OrderClause="$order_input"; info "ORDER BY clause set to: ${OrderClause:-<None>}"; show_select_state; return 0
}

handle_cmd_limit() {
  local limit_input=""; if [[ $# -eq 1 && -n "$1" ]]; then limit_input="$1"; elif [[ $# -ne 1 ]]; then read -e -p "LIMIT (number or blank to clear): " -i "$LimitClause" limit_input; limit_input=$(trim "$limit_input"); elif [[ $# -eq 1 && -z "$1" ]]; then read -e -p "LIMIT (number or blank to clear): " -i "$LimitClause" limit_input; limit_input=$(trim "$limit_input"); fi
  if [[ -z "$limit_input" ]]; then LimitClause=""; info "LIMIT cleared."; elif [[ "$limit_input" =~ ^[0-9]+$ ]]; then LimitClause="$limit_input"; info "LIMIT set to: $LimitClause"; else error "Invalid LIMIT value '$limit_input'. Must be a positive number."; return 1; fi
  show_select_state; return 0
}

handle_cmd_asc_desc() {
  local direction="$1"; if [[ "$direction" == "desc" ]]; then OrderDirection="DESC"; info "ORDER BY direction set to DESC."; else OrderDirection="ASC"; info "ORDER BY direction set to ASC."; fi
  show_select_state; return 0
}

handle_cmd_select() {
  # Verify context requirements
  if [[ -z "$Database" ]]; then
    error "No database selected (/database)."
    return 1
  fi
  
  if [[ -z "$DataTable" ]]; then
    error "No table selected (/table)."
    return 1
  fi
  
  # Build SQL query safely
  local sql="SELECT "
  
  # Handle column selection
  if [[ "${SelectedColumns[*]}" == "*" ]]; then
    sql+="*"
  else
    local quoted_cols=()
    local col
    for col in "${SelectedColumns[@]}"; do
      # Quote each column identifier
      quoted_cols+=("$(quote_ident "$col")")
    done
    sql+=$(IFS=,; echo "${quoted_cols[*]}")
  fi
  
  # Add table name (safely quoted)
  sql+=" FROM $(quote_ident "$DataTable")"
  
  # Add WHERE clause if specified (user is responsible for proper where clause syntax)
  if [[ -n "$WhereClause" ]]; then
    # Note: WhereClause is not auto-escaped as it may contain complex conditions
    # Users must be careful with this
    sql+=" WHERE $WhereClause"
  fi
  
  # Add ORDER BY if specified
  if [[ -n "$OrderClause" ]]; then
    # Split order clause by commas and quote each part
    local order_parts
    IFS=',' read -ra order_parts <<< "$OrderClause"
    local quoted_order_parts=()
    local part
    for part in "${order_parts[@]}"; do
      quoted_order_parts+=("$(quote_ident "$(trim "$part")")")
    done
    sql+=" ORDER BY $(IFS=,; echo "${quoted_order_parts[*]}") $OrderDirection"
  fi
  
  # Add LIMIT if specified
  if [[ -n "$LimitClause" ]]; then
    # Ensure limit is numeric
    if [[ "$LimitClause" =~ ^[0-9]+$ ]]; then
      sql+=" LIMIT $LimitClause"
    else
      error "Invalid LIMIT value: $LimitClause (must be numeric)"
      return 1
    fi
  fi
  
  # Execute the query
  info "Executing: $sql"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    {
      # Use table format with paging through less
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "$sql" | less -RS
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    }
  else
    # Use table format without paging if less isn't available
    mysql_run_display "$Database" --table -e "$sql"
  fi
  
  return $?
}

handle_cmd_desc() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  info "Structure for '$Database.$DataTable':"
  mysql_exec "$Database" -e "DESCRIBE $(quote_ident "$DataTable");" || return 1
  return 0
}

handle_cmd_structure() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  local format="$1"
  local quoted_table
  quoted_table=$(quote_ident "$DataTable")
  
  # Check if less is available
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  info "Detailed structure for '$Database.$DataTable':"
  
  # Determine format and pager options
  if [[ "$format" == "v" ]]; then
    # Vertical format
    if (( use_pager )); then
      # Use less with raw control chars (-R) and no line wrapping (-S)
      { 
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          -e "SHOW FULL COLUMNS FROM $quoted_table\G" | less -RS
        # Reset terminal after using less
        stty sane 2>/dev/null || true
      }
    else
      # Direct output without pager
      mysql_exec "$Database" -e "SHOW FULL COLUMNS FROM $quoted_table\G" || return 1
    fi
  else
    # Boxed tabular format
    if (( use_pager )); then
      # Use less with raw control chars (-R) and no line wrapping (-S)
      {
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "SHOW FULL COLUMNS FROM $quoted_table;" | less -RS
        # Reset terminal after using less
        stty sane 2>/dev/null || true
      }
    else
      # Direct output without pager but still boxed
      mysql_exec "$Database" --table -e "SHOW FULL COLUMNS FROM $quoted_table;" || return 1
    fi
  fi
  
  return 0
}

handle_cmd_status() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  info "Status for '$Database.$DataTable':"
  mysql_exec "$Database" -e "SHOW TABLE STATUS WHERE Name = $(escape_sql_value "$DataTable")\G" || return 1
  return 0
}

handle_cmd_create() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  info "CREATE TABLE statement for '$Database.$DataTable':"
  local create_statement
  create_statement=$(mysql_exec "$Database" -sN -e "SHOW CREATE TABLE $(quote_ident "$DataTable");") || return 1
  
  if [[ -n "$create_statement" ]]; then
    echo "$create_statement" | cut -f2-
  else
    error "Could not parse CREATE output."
    return 1
  fi
  
  return 0
}

handle_cmd_count() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  local count
  count=$(mysql_exec "$Database" -Nse "SELECT COUNT(*) FROM $(quote_ident "$DataTable");") || return 1
  info "Row count for '$Database.$DataTable': $count"
  return 0
}

handle_cmd_sql() {
  local sql_command="$*"
  
  if [[ -z "$Database" ]]; then
    error "No database selected (/database)."
    return 1
  fi
  
  if [[ -z "$sql_command" ]]; then
    error "Usage: /sql <SQL query...>"
    return 1
  fi
  
  # Display warning for potentially destructive operations
  if [[ "$sql_command" =~ ^[[:space:]]*(DROP|DELETE|TRUNCATE|UPDATE|ALTER)[[:space:]] ]]; then
    warn "Executing potentially destructive operation: $sql_command"
    read -p "Are you sure you want to continue? (y/N): " -n 1 -r confirm
    echo
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
      info "Operation cancelled."
      return 0
    fi
  fi
  
  info "Executing SQL in '$Database': $sql_command"
  mysql_exec "$Database" -e "$sql_command"
  return $?
}

handle_cmd_prompt() {
  [[ -z "$Database" ]] && { error "No database selected (/database)."; return 1; }
  info "Launching interactive MySQL prompt for database '$Database'..."; info "Type 'exit' or 'quit' to return to $PRG."; stty sane
  if ! mysql --defaults-file="$PROFILE" --no-auto-rehash --prompt="[$PRG:$Database] mysql> " "$Database"; then error "MySQL interactive session exited."; fi
  stty sane; clear; info "Returned to $PRG. Current context: $PromptPrefix"; bind '"\e[0n": redraw-current-line'; printf '\e[0n' > /dev/tty; return 0
}

#=============================================================================
# Main Execution Logic
# Handles startup, arguments, and interactive command loop
#=============================================================================
main() {
  # --- Argument Parsing ---
  local -i InteractiveMode=1
  
  while (($#)); do 
    case "$1" in 
      -p|--profile)
        noarg "$@"
        shift
        PROFILE="$1"
        ;;
      -v|--verbose)
        VERBOSE+=1
        ;;
      -q|--quiet)
        VERBOSE=0
        ;;
      -V|--version)
        echo "$PRG v$VERSION"
        exit 0
        ;;
      -h|--help)
        usage 0
        ;;
      # Handle combined short options (e.g., -vq)
      -[pvqhV]*)
        # Loop through each character and add as separate option
        local char
        for char in $(echo "${1:1}" | grep -o .); do
          set -- "$@" "-$char"
        done
        shift # Remove the original combined option
        continue # Restart the loop to process the new options
        ;;
      --)
        shift
        break
        ;;
      -*)
        usage 22 "Invalid option '$1'"
        ;;
      *)
        # Positional arguments
        if [[ -z "$Database" ]]; then
          Database="$1"
        elif [[ -z "$DataTable" ]]; then
          DataTable="$1"
        else
          usage 22 "Too many arguments: '$1'"
        fi
        ;;
    esac
    shift
  done
  
  # Process any remaining arguments
  while (($#)); do
    if [[ -z "$Database" ]]; then
      Database="$1"
    elif [[ -z "$DataTable" ]]; then
      DataTable="$1"
    else
      usage 22 "Too many arguments: '$1'"
    fi
    shift
  done

  # --- Profile Validation & Connection Check ---
  # Set default profile if none specified
  if [[ -z "$PROFILE" ]]; then
    PROFILE=$Profile_Default
  fi
  
  # Store original path for error messages
  local profile_path="$PROFILE"
  
  # Try relative path if profile not found and path isn't absolute
  if ! [[ -f "$PROFILE" ]] && [[ "$PROFILE" != /* ]]; then
    if [[ -f "$PRGDIR/$PROFILE" ]]; then
      PROFILE="$PRGDIR/$PROFILE"
      debug "Found profile at relative path: $PROFILE"
    fi
  fi

  # Find the canonical profile path
  local resolved_profile=""
  local -i resolve_status=1 # Default to failure
  
  # Attempt path resolution with realpath or readlink
  if command -v realpath >/dev/null; then
    # Try realpath first (preferred)
    resolved_profile=$(realpath -m -q -- "$PROFILE" 2>/dev/null)
    resolve_status=$?
    
    if (( resolve_status != 0 )); then
      warn "Could not resolve profile path with realpath: '$profile_path'"
    else
      debug "Resolved profile path using realpath: $resolved_profile"
    fi
  fi
  
  # Fall back to readlink if realpath failed or wasn't available
  if (( resolve_status != 0 )) && command -v readlink >/dev/null; then
    debug "Attempting to resolve profile path with readlink"
    resolved_profile=$(readlink -m -- "$PROFILE" 2>/dev/null)
    resolve_status=$?
    
    if (( resolve_status != 0 )); then
      warn "Could not resolve profile path with readlink: '$profile_path'"
    else
      debug "Resolved profile path using readlink: $resolved_profile"
    fi
  fi
  
  # Last resort: use the original path if it exists
  if (( resolve_status != 0 )); then
    if [[ -f "$PROFILE" ]]; then
      warn "Using unresolved profile path: '$PROFILE'"
      resolved_profile="$PROFILE"
      resolve_status=0
    else
      die 1 "Could not find or access profile at path: '$profile_path'"
    fi
  fi
  
  # Use the resolved path
  PROFILE="$resolved_profile"
  
  # Final check: Does the resolved path exist as a file?
  if [[ ! -f "$PROFILE" ]]; then
    die 2 "Profile file not found: '$PROFILE' (original: '$profile_path')"
  fi
  
  # Check if profile is readable
  if [[ ! -r "$PROFILE" ]]; then
    die 2 "Profile file exists but is not readable: '$PROFILE'"
  fi
  
  debug "Using MySQL profile: $PROFILE"

  # --- Prerequisite Checks ---
  command -v mysql >/dev/null || die 1 "MySQL client 'mysql' not found."
  (( VERBOSE > 0 )) && info "Checking initial connection..."
  local init_check_status=0
  mysql_exec -e "SELECT 1;" >/dev/null || init_check_status=$? # Suppress "1" output
  if (( init_check_status != 0 )); then die 1 "Initial connection failed using profile '$PROFILE'. Check errors."; fi
  (( VERBOSE > 0 )) && success "Connection successful." && info "Using profile '$PROFILE'"

  # --- Initial Context Setup ---
  if [[ -n "$Database" ]]; then
      # Use || true to prevent exit if initial context setting fails
      set_database_context "$Database" || true
      # Only try setting table if DB was set successfully
      if [[ -n "$Database" && -n "$DataTable" ]]; then
          set_table_context "$DataTable" || true
      fi
  fi

  # --- Startup Behavior: Ensure Database is Selected ---
  if (( InteractiveMode )) && [[ -z "$Database" ]]; then
    info "No initial database selected. Please choose one:"
    handle_cmd_databases || true # Prevent exit if user cancels selection
    # If still no DB after menu (user cancelled), exit cleanly.
    [[ -z "$Database" ]] && { info "No database selected. Exiting."; exit 0; }
  fi

  # --- Interactive Mode Loop ---
  info "Starting interactive mode. Type '/help' for commands, '/q' to quit."
  local input raw_cmd cmd args
  while true; do
    # Check if read returns non-zero (EOF)
    if ! read -e -p "$PromptPrefix> " input; then info "EOF detected. Exiting."; echo; break; fi
    input=$(trim "$input"); [[ -z "$input" ]] && continue
    history -s "$input"
    # Process input based on first character
    if [[ "$input" =~ ^/ ]]; then
      # Handle slash commands (/command)
      raw_cmd="${input:1}";
      if [[ "$raw_cmd" =~ ^([a-zA-Z0-9_?]+)[[:space:]]+(.*)$ ]]; then 
        cmd="${BASH_REMATCH[1]}"
        args="${BASH_REMATCH[2]}"
      elif [[ "$raw_cmd" =~ ^([a-zA-Z0-9_?]+)$ ]]; then 
        cmd="$raw_cmd"
        args=""
      elif [[ "$raw_cmd" =~ ^(\.\.|0|back)$ ]]; then 
        cmd="$raw_cmd"
        args=""
      elif [[ -z "$raw_cmd" ]]; then 
        continue
      else
        error "Invalid command format: '$input'"
        continue
      fi
      
      # Execute command handlers, append '|| true' to prevent set -e exit
      case "$cmd" in
        help|\?)        handle_cmd_help || true ;;
        databases)      handle_cmd_databases || true ;;
        database)       handle_cmd_database "$args" || true ;;
        tables)         handle_cmd_tables || true ;;
        table)          handle_cmd_table "$args" || true ;;
        columns)        handle_cmd_columns "$args" || true ;;
        where)          handle_cmd_where "$args" || true ;;
        order)          handle_cmd_order "$args" || true ;;
        asc)            handle_cmd_asc_desc "asc" || true ;;
        # DESC is now only for sort order
        desc)           handle_cmd_asc_desc "desc" || true ;;
        limit)          handle_cmd_limit "$args" || true ;;
        select)         handle_cmd_select || true ;;
        state)          show_select_state || true ;;
        # These commands require a table to be selected
        describe)       handle_cmd_desc || true ;; # Table structure command
        structure)      handle_cmd_structure "$args" || true ;; # Detailed column information
        status)         handle_cmd_status || true ;;
        create)         handle_cmd_create || true ;;
        count)          handle_cmd_count || true ;;
        # General commands
        sql)            handle_cmd_sql "$args" || true ;;
        prompt)         handle_cmd_prompt || true ;;
        # Navigation
        ..|0|back)      go_back_context || true ;;
        q|quit|exit)    info "Exiting."; break ;; # Exit loop cleanly
        *)              error "Unknown command '/$cmd'. Type '/help' for options." ;;
      esac
    elif [[ "$input" =~ ^! ]]; then
      # Handle shell commands (!command)
      if [[ "$input" == "!" ]]; then
        # Just '!' launches interactive shell
        handle_shell_command || true
      else
        # '!command' or '!shell command' executes command
        if [[ "$input" =~ ^!shell[[:space:]]+(.*)$ ]]; then
          # '!shell command' syntax
          handle_shell_command "${BASH_REMATCH[1]}" || true
        else
          # '!command' syntax - remove the leading ! and pass rest as command
          handle_shell_command "${input:1}" || true
        fi
      fi
    else
      # Treat as direct SQL command if a database is selected
      if [[ -n "$Database" ]]; then
        info "Executing SQL in '$Database': $input"
        mysql_run_display "$Database" --table -e "$input" || true
      else
        error "No database selected. Select a database with /database first, or use / or ! commands."
        info "Type '/help' for available commands or '/databases' to select a database."
      fi
    fi
  done # End while loop
  success "Exiting."
}
# --- Script Entry Point ---
main "$@"
#fin

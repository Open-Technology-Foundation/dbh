#!/usr/bin/env bash
# shellcheck disable=SC2162 # Allow read without -r for backward compatibility
#
# dbh - Interactive MySQL Database Helper (v3.7.1)
#
# A powerful, intuitive MySQL database explorer with an interactive command interface,
# colorized output, and comprehensive database management capabilities.
#
# Features:
# - Interactive hierarchical database/table navigation with /commands
# - Color-coded interface with context-aware prompts
# - Query building with columnar selection and filtering
# - SQL execution and formatting with secure parameter handling
# - Shell command access with ! prefix while maintaining context
# - Configuration system via ~/.config/dbh/config
# - Persistent command history with readline/arrow key support
# - Database schema exploration and visualization
# - Table structure and relationship analysis
# - Export capabilities (CSV, SQL, JSON formats)
# - Security features including SQL injection prevention
#
# Copyright (C) 2023-2025 Open Technology Foundation
# License: GNU General Public License v3.0 (GPL-3.0)
# Repository: https://github.com/Open-Technology-Foundation/dbh
#
# Usage: dbh [Options] [database [table [command]]]
# See /help for detailed command information
set -eEuo pipefail +o histexpand
shopt -s extglob globstar checkwinsize inherit_errexit

# --- Config & History Setup ---
declare -i HISTSIZE=1000
declare -i HISTFILESIZE=2000
shopt -s histappend

declare -x LESS='-FXRS'

# Setup directory and files
declare -- DBH_CONFIG_DIR="$HOME"/.config/dbh
declare -- DBH_CONFIG_FILE="$DBH_CONFIG_DIR"/config
declare -- DBH_HISTORY_FILE="$DBH_CONFIG_DIR"/history
declare -- DBH_READLINE_HISTORY="$DBH_CONFIG_DIR"/readline_history
declare -r HISTFILE="$DBH_READLINE_HISTORY"  # For arrow key navigation

# Create config directory if needed
if [[ ! -d "$DBH_CONFIG_DIR" ]]; then
  mkdir -p "$DBH_CONFIG_DIR" || warn "Could not create directory ${DBH_CONFIG_DIR@Q}"
fi

# Load user configuration from ~/.config/dbh/config
# 
# Reads and processes the user's configuration file, supporting the following settings:
# - DEFAULT_PROFILE: Path to MySQL configuration file
# - DEFAULT_DATABASE: Initial database to connect to (if not specified on command line)
# - DEFAULT_LIMIT: Default limit for SELECT queries (default: 100)
# - MAX_HISTORY: Maximum number of history entries to store
# - PAGER: Custom pager program for large outputs
#
# This function safely handles errors by temporarily disabling errexit mode
# and restoring it afterward. Empty config files and missing config files are
# handled gracefully.
load_config() {
  local -i old_errexit=0
  [[ $- == *e* ]] && old_errexit=1 ||:
  set +e

  if [[ -r "$DBH_CONFIG_FILE" && -s "$DBH_CONFIG_FILE" ]]; then
    local -- line key value
    local -i count=0

    while IFS= read -r line || [[ -n "$line" ]]; do
      # Skip empty lines and comments
      [[ -z "$line" || ${line:0:1} == "#" ]] && continue ||:

      # Parse key=value pairs with regex
      if [[ "$line" =~ ^([A-Za-z0-9_]+)=(.*)$ ]]; then
        key="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"
        # Remove surrounding quotes if present
        value="${value#[\"\']}"; value="${value%[\"\']}"

        # Apply configuration settings based on key
        case "$key" in
          DEFAULT_PROFILE)   Profile_Default="$value"; count+=1 ;;
          DEFAULT_DATABASE)  [[ -n "$Database" ]] || Database="$value"; count+=1 ;;
          DEFAULT_LIMIT)     LimitClause="$value"; count+=1 ;;
          MAX_HISTORY)       HISTSIZE="$value"; HISTFILESIZE="$value"; count+=1 ;;
          PAGER)             PAGER="$value"; count+=1 ;;
        esac
      fi
    done < "$DBH_CONFIG_FILE" 2>/dev/null || true

    # Inform user about loaded settings (only if interactive)
    ((count)) && [[ -t 1 ]] && info "Loaded $count configuration settings" ||:
  fi

  # Restore original errexit state
  ((old_errexit)) && set -e
  return 0
}

declare -r VERSION=3.7.1
# Get script path and extract directory/program name
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0") || { echo "ERROR: Could not resolve script path"; exit 1; }
declare -r SCRIPT_DIR="${SCRIPT_PATH%/*}" SCRIPT_NAME="${SCRIPT_PATH##*/}"

# --- Messaging Functions ---
declare -i VERBOSE=1 DEBUG=0
if [[ -t 2 ]]; then
  declare -r RED=$'\e[1;31m' YELLOW=$'\e[1;33m' GREEN=$'\e[1;32m' CYAN=$'\e[1;36m' LIGHT_YELLOW=$'\e[0;33m' NOCOLOR=$'\e[0m'
else
  declare -r RED='' YELLOW='' GREEN='' CYAN='' LIGHT_YELLOW='' NOCOLOR=''
fi

_message() { # type (1=info, 2=warn, 3=error, 4=success, 5=debug), prefix, text
  local -i type=$1 use_stderr=0
  local -- prefix=$3 text=$4 color=$NOCOLOR
  case $type in
    2) color=$YELLOW; use_stderr=1;;
    3) color=$RED; use_stderr=1;;
    4) color=$GREEN;;
    5) ((DEBUG)) || return 0; color="$CYAN"; use_stderr=1;;
    *) color=$NOCOLOR;;
  esac
  if (( type > 1 || VERBOSE > 0 )); then
    printf '%s%s%s%s\n' "$color" "$prefix" "$text" "$NOCOLOR" >&"$((use_stderr + 1))"
  fi
  return 0 # Messaging itself should not cause script exit via set -e
}
info()    { _message 1 '' '' "$*"; }
warn()    { _message 2 '' "WARN: " "$*"; }
error()   { _message 3 '' "ERROR: " "$*"; }
success() { _message 4 '' "OK: " "$*"; }
debug()   { _message 5 '' "DEBUG: " "$*"; }
die()     { _message 3 '' "FATAL: " "${2:-"Unknown error"}"; exit "${1:-1}"; }
# --- End Messaging ---

# --- Standard Utility Overrides/Helpers ---
# Function to color prompt text
prompt() {
  # Only apply color if terminal supports it
  if [[ -t 1 ]]; then
    echo -n "${LIGHT_YELLOW}$*${NOCOLOR}"
  else
    echo -n "$*"
  fi
}
# Use absolute paths to prevent command injection
grep() { command /usr/bin/grep "$@"; }
find() { command /usr/bin/find "$@"; }
sed() { command /usr/bin/sed "$@"; }
declare -fx grep find sed
# --- End Utility Overrides ---

# --- Script Helpers ---
noarg() { if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then die 2 "Missing argument for option ${1@Q}"; fi; true; }
decp() { declare -p "$@" | sed 's/^declare -[a-zA-Z-]* //'; }
trim() { local v="$*"; v="${v#"${v%%[![:blank:]]*}"}"; echo -n "${v%"${v##*[![:blank:]]}"}"; }

# Function to safely quote SQL identifiers
# 
# Properly escapes a MySQL identifier (table name, column name, etc.) by:
# 1. Surrounding it with backticks to handle reserved words and special characters
# 2. Escaping any backticks within the identifier by doubling them
#
# This is CRITICAL for SQL injection prevention when using user-provided identifiers
# in SQL statements.
#
# Args:
#   $1 - The SQL identifier to quote (table name, column name, etc.)
# Returns:
#   The properly quoted identifier
quote_ident() { 
  local -- ident=$1
  # Double backticks within identifiers (MySQL's escaping rule for identifiers)
  ident="${ident//\`/\`\`}"
  echo "\`$ident\`"
}

# Function to safely escape values for SQL WHERE clauses and other string contexts
# 
# Properly escapes a string value to prevent SQL injection by:
# 1. Replacing single quotes with two single quotes (SQL standard escaping)
# 2. Surrounding the result with single quotes
#
# This is CRITICAL for SQL injection prevention when using user-provided values
# in SQL statements.
#
# Args:
#   $1 - The string value to escape
# Returns:
#   The properly escaped and quoted string value
escape_sql_value() {
  local -- value=$1
  # Replace single quotes with two single quotes (SQL standard escaping)
  value="${value//\'/\'\'}"
  echo "'$value'"
}

# Create a random temporary file with secure permissions
# 
# Creates a temporary file with restrictive permissions (only readable/writable
# by the current user) to prevent information leakage or unauthorized access.
#
# Uses the system's temporary directory or falls back to /tmp if needed.
# Applies 0600 permissions (user read/write only).
#
# Args:
#   $1 - Prefix for the temporary file name
# Returns:
#   The path to the created temporary file
create_secure_tempfile() {
  local -- prefix=$1
  local -- tmp_dir=${TMPDIR:-/tmp}
  
  # Fall back to /tmp if the specified temp directory doesn't exist or isn't writable
  [[ -d "$tmp_dir" && -w "$tmp_dir" ]] || tmp_dir=/tmp
  
  # Create temp file with a unique name
  local -- temp_file
  temp_file=$(TMPDIR="$tmp_dir" mktemp "${prefix}.XXXXXXXXXX")
  
  # Apply restrictive permissions - only owner can read/write
  chmod 0600 "$temp_file"
  
  # Return the path to the created file
  echo "$temp_file"
}

# MySQL execution wrapper with improved security
#
# A secure wrapper around the MySQL client that:
# 1. Uses secure temporary files for output redirection
# 2. Properly captures and formats error messages
# 3. Handles cleanup with traps
# 4. Uses the selected MySQL profile
# 5. Formats error messages in a user-friendly way
#
# All MySQL operations should use this function to ensure consistent
# security and error handling throughout the application.
#
# Args:
#   $@ - Arguments to pass to the MySQL client
# Returns:
#   MySQL command output on success, error message on failure
# Exit codes:
#   MySQL client exit code is preserved and returned
mysql_exec() {
  local -- output='' error=''
  local -i exit_code=1
  local -- out_file err_file

  # Create secure temp files and set cleanup trap
  out_file=$(create_secure_tempfile "${SCRIPT_NAME}.out")
  err_file=$(create_secure_tempfile "${SCRIPT_NAME}.err")
  trap 'rm -f "$out_file" "$err_file"; trap - RETURN' RETURN

  # Execute command with the profile variable from main scope
  ((DEBUG)) || debug "MySQL: $*"
  mysql --defaults-file="$PROFILE" --no-auto-rehash "$@" >"$out_file" 2>"$err_file"
  exit_code=$?

  # Read results and cleanup
  output=$(< "$out_file")
  error=$(< "$err_file")
  rm -f "$out_file" "$err_file"
  trap - RETURN

  # Output stdout regardless of exit status
  [[ -z "$output" ]] || echo "$output"

  # Handle errors
  if ((exit_code)); then
    # Parse and format MySQL error messages for better readability
    local -- mysql_err_msg
    mysql_err_msg=$(echo "$error" | sed -n 's/^.*ERROR[[:space:]]*[0-9]*[[:space:]]*(\(.*\)).*:[[:space:]]*\(.*\)/\1: \2/p' | head -n 1)
    
    # Display appropriate error message
    if [[ -n "$mysql_err_msg" ]]; then
      error "MySQL Error: $mysql_err_msg"
    else
      [[ -z "$error" ]] || error "MySQL Error: ${error}"
    fi

    return $exit_code
  elif [[ -n "$error" ]]; then 
    # Handle warnings (non-fatal errors)
    warn "MySQL produced warnings: ${error}"
  fi
  
  return 0
}

# MySQL execution with direct terminal output for interactive display
#
# Unlike mysql_exec, this function lets MySQL output directly to the 
# terminal for better formatting with tables and interactive paging.
# Used for SELECT statements and other queries where formatted output
# is important for readability.
#
# Args:
#   $1 - Database name to use
#   $@ - Additional arguments to pass to MySQL
# Returns:
#   0 on success, non-zero on failure
#   Output goes directly to the terminal
mysql_run_display() {
  # Expects DB name as $1, then mysql arguments (like -e "SQL")
  local -- db_name=$1
  shift # Remove db_name from args list

  debug "Executing MySQL display command with profile ${PROFILE@Q} for DB ${db_name@Q}: $*"
  
  # Execute directly, letting output go to terminal
  # This allows for proper table formatting and interactive display
  mysql --defaults-file="$PROFILE" --no-auto-rehash "$db_name" "$@"
  local -i exit_code=$?
  debug "MySQL display command finished, exit_code=$exit_code"

  if ((exit_code)); then
    # Error messages likely already printed by mysql to stderr
    error "MySQL display command failed (Exit Code: $exit_code)" # error() returns 0
    return $exit_code # Return non-zero status
  fi
  
  return 0 # Success
}
# Shell execution - Launch interactive shell or run shell command
handle_shell_command() {
  local -- cmd="$*"
  
  # Save terminal state
  local saved_stty
  saved_stty=$(stty -g 2>/dev/null) || true
  
  info "Launching shell $([[ -n "$cmd" ]] && echo "command: $cmd" || echo "session")..."
  
  local -i exit_code=0
  if [[ -n "$cmd" ]]; then
    # Execute specific command
    bash -c "$cmd"
    exit_code=$?
    
    # Provide a prompt to continue after viewing output
    if [[ -t 0 && -t 1 ]]; then  # Only if both stdin and stdout are terminals
      echo
      prompt 'Press Enter to continue... '
      read -n 1 -s
      echo
    fi
  else
    # Launch interactive shell
    if [[ -n "$SHELL" ]]; then
      "$SHELL"
    else
      bash
    fi
    exit_code=$?
  fi
  
  # Restore terminal state
  stty "$saved_stty" 2>/dev/null || true
  
  if ! ((exit_code)); then
    info "Shell session completed. Returned to $SCRIPT_NAME."
  else
    warn "Shell exited with status $exit_code. Returned to $SCRIPT_NAME."
  fi
  
  return 0
}

# --- End Helpers & Command Handlers ---

# --- Global Variables & State Management ---
declare -x Profile_Default="$HOME"/.mylocalhost.cnf
declare -xg PROFILE='' Database='' DataTable='' PAGER=''
# State for building SELECT queries
declare -ga SelectedColumns=('*') # Array of column names, default '*'
declare -g WhereClause='' OrderClause='' OrderDirection='ASC' LimitClause='100'
declare -g PromptPrefix='[dbh]'
# History tracking for /history command
declare -a CommandHistory=()

# Load history from file
load_history() {
  CommandHistory=()

  local -i old_errexit=0
  [[ $- == *e* ]] && old_errexit=1 ||:
  set +e

  history -c

  if [[ -r "$DBH_HISTORY_FILE" && -s "$DBH_HISTORY_FILE" ]]; then
    local -- line
    local -i count=0

    while IFS= read -r line || [[ -n "$line" ]]; do
      [[ -n "$line" ]] || continue

      CommandHistory+=("$line")
      history -s "$line" 2>/dev/null || true
      count+=1
    done < "$DBH_HISTORY_FILE" 2>/dev/null || true

    history -w "$HISTFILE" 2>/dev/null || true

    ((count)) && [[ -t 1 ]] && info "Loaded $count history entries" ||:
  elif [[ -t 1 ]]; then
    info 'No history file found'
  fi

  ((old_errexit)) && set -e
  return 0
}

# Save history to file
save_history() {
  local -i old_errexit=0
  [[ $- == *e* ]] && old_errexit=1 ||:
  set +e

  if [[ -d "$DBH_CONFIG_DIR" ]]; then
    if ! ((${#CommandHistory[@]})); then
      ((old_errexit)) && set -e
      return 0
    fi

    local -i result=0
    printf "%s\n" "${CommandHistory[@]}" 2>/dev/null > "$DBH_HISTORY_FILE" || result=$?

    if ! ((result)); then
      chmod 600 "$DBH_HISTORY_FILE" 2>/dev/null || true
      if [[ -f "$HISTFILE" ]]; then
        chmod 600 "$HISTFILE" 2>/dev/null || true
      fi

      [[ -t 1 ]] && info "Saved ${#CommandHistory[@]} history entries" ||:
    fi
  elif [[ -t 2 ]]; then
    warn "Could not save history: Directory $DBH_CONFIG_DIR missing"
  fi

  ((old_errexit)) && set -e
  return 0
}
# --- End Globals ---

# --- Context Validation Helpers ---
# 
# These helper functions are used to check the current database and table context
# and provide consistent error messaging throughout the application.
#
# Using these helpers instead of direct checks reduces code duplication
# and ensures consistent user feedback.

# Validate that a database is selected
#
# Args:
#   $1 - Optional: Alternative error message
# Returns:
#   0 if database is selected, 1 otherwise
# Side effects:
#   Prints error message if no database is selected
require_database() {
  local custom_error=$1
  
  if [[ -z "$Database" ]]; then
    error "${custom_error:-"No database selected. Use /database first."}"
    return 1
  fi
  
  return 0
}

# Validate that a table is selected
#
# Args:
#   $1 - Optional: Alternative error message
# Returns:
#   0 if table is selected, 1 otherwise (also fails if no database is selected)
# Side effects:
#   Prints error message if no database or table is selected
require_table() {
  local -- custom_error=$1
  
  # First check database context
  require_database || return 1
  
  if [[ -z "$DataTable" ]]; then
    error "${custom_error:-'No table selected. Use /table first.'}"
    return 1
  fi
  
  return 0
}
# --- End Context Validation Helpers ---

# --- Cleanup ---
xcleanup() {
  set +e
  
  local -i exitcode=${1:-$?}
  
  [[ -t 0 ]] && printf '\e[?25h' >&2 ||:
  save_history
  
  find "${TMPDIR:-/tmp}" -maxdepth 1 -type f -name "${SCRIPT_NAME}.*.????????" -user "$(id -u)" -delete 2>/dev/null || true
  
  ((exitcode==0 || exitcode > 128)) && exit "$exitcode" ||:
  
  return 0
}

# Set trap for cleanup on exit
trap 'xcleanup $?' EXIT TERM INT HUP
# --- End Cleanup ---

usage() {
  cat <<HELP
$SCRIPT_NAME $VERSION - Interactive MySQL client with slash commands, shell access, and direct SQL

Usage:
  $SCRIPT_NAME [Options] [database [table [command]]]

  database  Optional: Initial database to connect to
  table     Optional: Initial table to select
  command   Optional: Initial command to execute

Options:
  -p, --profile PROFILE  MySQL config file (Default: $Profile_Default)
  -v, --verbose   Increase verbosity
  -q, --quiet     Suppress non-error messages
  -V, --version   Print version and exit
  -h, --help      Display this help

Command Types:
  /command          Slash commands for database operations
  !command          Shell commands (!alone for interactive shell)
  SQL               Direct SQL when not starting with / or !
  !number           Repeat command from history by number

Database Navigation:
  /help             Show available commands
  /databases        List & select database via menu
  /database <db>    Directly select database
  /tables           List & select table via menu
  /table <name>        Directly select table
  /.. | /0 | /back  Go back one level (Table->DB->Exit)
  /q | /quit | /exit Exit the shell

Query Building:
  /columns [c1,c2]  Set columns (shows multi-select menu)
  /where [clause]   Set WHERE clause
  /order [col(s)]   Set ORDER BY columns
  /asc | /desc      Set ORDER BY direction
  /limit [num]      Set LIMIT
  /select           Execute query with current state
  /state            Show query state

Table Operations:
  /describe         Show table structure 
  /structure [v]    Detailed column info (v=vertical)
  /status           Show table status
  /create           Show CREATE statement
  /count            Show row count
  /sample [n]       Show n sample rows (default: 10)
  /primary-key      Show primary key columns
  /indexes          Show all indexes
  /foreign-keys     Show foreign key relationships
  /find <text>      Search for text in all columns
  /backup [file]    Backup table to SQL file

Database Operations:
  /schema [v]       Show database schema with relationships
  /charset          Show character set information
  /engines          List available storage engines
  /backup [file]    Backup current database to SQL file

Administration:
  /whoami           Show current MySQL user and privileges
  /whois [user]     Show information about a specific MySQL user
  /users            Show MySQL users and privileges
  /processes        Show active MySQL processes
  /variables [filter] Display MySQL system variables
  /stats            Show database/table statistics
  /export [file]    Export query results to file (CSV/SQL/JSON)
  /sql <SQL>        Execute arbitrary SQL
  /prompt           Open MySQL prompt

Shell Access:
  !                 Interactive shell (returns to dbh)
  !command          Execute shell command
  !shell command    Alternative syntax
  ↑/↓               Use arrow keys to navigate command history
  !number           Repeat command from history by number
  /history [n]      Show command history (last n entries, persistent across sessions)
  /config           Manage configuration settings (show, create, edit, reload)

Examples:
  $SCRIPT_NAME mydb users # Start in mydb.users
  [dbh:mydb:users]> /columns id,name,email
  [dbh:mydb:users]> /where active=1
  [dbh:mydb:users]> /select
  [dbh:mydb:users]> SELECT * FROM users WHERE id=123
  [dbh:mydb:users]> ! ls -la
  [dbh:mydb:users]> /q

HELP
  (($#)) && exit "${1:-0}"
  return 0
}

#=============================================================================
# Database and Table Context Management
# Handles selection, validation, and context switching
#=============================================================================
# The context management system is a core component of dbh that maintains
# the current database and table selection state. It provides hierarchical
# navigation with proper validation and security checks.

# Sets the database context, clears table selection, and updates prompt
#
# This function sets the current working database context after validating
# that the database exists and is accessible. It updates the prompt to show
# the current context and triggers a table listing for the new database.
#
# Security note: Uses proper SQL injection prevention techniques with
# quote_ident() for safe database name handling.
#
# Args:
#   $1 - Database name to select
# Returns:
#   0 on success, 1 on failure (database doesn't exist or access denied)
# Side effects:
#   - Sets the global Database variable
#   - Clears the DataTable variable
#   - Updates the PromptPrefix
#   - Shows available tables if database changed
set_database_context() {
  local db_name="$1"
  local db_check_status=0
  
  # Safely quote database name to prevent SQL injection
  local quoted_db_name
  quoted_db_name=$(quote_ident "$db_name")
  
  # Check if database exists and is accessible by attempting to USE it
  mysql_exec -e "USE ${quoted_db_name};" >/dev/null 2>&1 || db_check_status=$?
  
  if ! ((db_check_status)); then
    # Store previous database to check if it changed
    local previous_db="$Database"
    
    # Set new database context
    Database="$db_name"
    DataTable='' # Clear table selection when database changes
    PromptPrefix="[dbh:$Database]" # Update prompt to show current context
    success "Using database ${Database@Q}"
    
    # If database has changed, show tables menu
    if [[ "$previous_db" != "$Database" ]]; then
      info "Showing available tables in ${Database@Q}..."
      # Show tables but don't return error if user cancels
      handle_cmd_tables || true
    fi
    
    return 0
  else
    # Database not accessible, reset context
    Database=''
    DataTable=''
    PromptPrefix="[dbh]"
    error "Cannot use database ${db_name@Q}. Does it exist and do you have access rights?"
    return 1
  fi
}

# Sets the table context and updates prompt
#
# This function sets the current working table context after validating
# that the table exists in the current database. It updates the prompt to
# show the current database and table context.
#
# Security note: Uses proper SQL injection prevention with escape_sql_value()
# for safe table name handling.
#
# Args:
#   $1 - Table name to select
# Returns:
#   0 on success, 1 on failure (no database selected, table doesn't exist)
# Side effects:
#   - Sets the global DataTable variable
#   - Updates the PromptPrefix
set_table_context() {
  local table_name="$1"
  
  # Verify database context exists before setting table
  if [[ -z "$Database" ]]; then
    error "No database selected. Use /database first."
    return 1
  fi
  
  # Safely escape table name for use in SQL queries
  local table_check_status=0
  local check_output
  
  # Check if table exists using information_schema to prevent direct manipulation
  check_output=$(mysql_exec "$Database" -Nse "SELECT table_name FROM information_schema.tables 
                                             WHERE table_schema = $(escape_sql_value "$Database") 
                                             AND table_name = $(escape_sql_value "$table_name") 
                                             LIMIT 1;") || table_check_status=$?
  
  if ((table_check_status)) || [[ -z "$check_output" ]]; then
    error "Table ${table_name@Q} not found in database ${Database@Q}"
    return 1
  else
    # Table exists, set context
    DataTable="$table_name"
    PromptPrefix="[dbh:$Database:$DataTable]" # Update prompt with database and table
    success "Using table ${DataTable@Q}"
    return 0
  fi
}

# Go back one context level in the navigation hierarchy
#
# This function implements a "back" navigation command that moves up
# in the context hierarchy: Table -> Database -> Top Level.
#
# Args:
#   None
# Returns:
#   Always returns 0 (success)
# Side effects:
#   - May clear DataTable or Database variables
#   - Updates the PromptPrefix accordingly
go_back_context() {
  if [[ -n "$DataTable" ]]; then 
    # If table is selected, go back to database level
    DataTable=''
    PromptPrefix="[dbh:$Database]"
    info "Returned to database ${Database@Q}"
  elif [[ -n "$Database" ]]; then 
    # If database is selected but no table, go back to top level
    Database=''
    PromptPrefix="[dbh]"
    info "Returned to top level."
  else 
    # Already at top level
    info "Already at the top level. Use /q to quit."
  fi
  return 0
}

# Display current SELECT query state
#
# Shows the current state of the SELECT query being built, including
# database, table, columns, WHERE, ORDER BY, and LIMIT clauses.
#
# Args:
#   None
# Returns:
#   Always returns 0 (success)
# Side effects:
#   Displays the current query state information to the user
show_select_state() {
  info "--- Current SELECT State ---"
  info " Database: ${Database:-<None>}"
  info " Table:    ${DataTable:-<None>}"
  
  # Format column list for display
  local cols_display="${SelectedColumns[*]}"
  [[ "$cols_display" == "*" ]] || cols_display=$(IFS=,; echo "${SelectedColumns[*]}")
  
  info " Columns:  $cols_display"
  info " WHERE:    ${WhereClause:-<None>}"
  info " ORDER BY: ${OrderClause:-<None>} $OrderDirection"
  info " LIMIT:    ${LimitClause:-<None>}"
  info "----------------------------"
  return 0
}

#=============================================================================
# Interactive Command Handlers
# Processes /commands, !shell commands, and direct SQL
#=============================================================================
# The command handlers are the core functionality of dbh, each implementing a
# specific operation that the user can invoke with a /<command> syntax.
#
# Each handler follows a consistent pattern:
# - Function name: handle_cmd_<command>
# - Return values: 0 for success, non-zero for failure
# - Error handling: Reports errors via error() function
# - Context checking: Verifies appropriate database/table context as needed
#
# Security is prioritized throughout, with all user inputs properly escaped
# before being used in SQL statements via quote_ident() and escape_sql_value().
#=============================================================================

handle_cmd_config() {
  local subcommand="$1"
  
  case "$subcommand" in
    show)
      info '---------------- Configuration Settings ----------------'
      info "Configuration file: $DBH_CONFIG_FILE"
      if [[ -r "$DBH_CONFIG_FILE" && -s "$DBH_CONFIG_FILE" ]]; then
        echo
        grep -v '^#' "$DBH_CONFIG_FILE" 2>/dev/null | grep . || echo "[No settings found]"
      else
        info "No configuration file found. Create one with '/config create'."
      fi
      echo
      echo 'Available options:'
      echo 'DEFAULT_PROFILE   - MySQL config file path (default: ~/.mylocalhost.cnf)'
      echo 'DEFAULT_DATABASE  - Database to connect to on startup'
      echo 'DEFAULT_LIMIT     - Default limit for SELECT queries (default: 100)'
      echo 'MAX_HISTORY       - Maximum history entries (default: 1000)'
      echo 'PAGER             - Custom pager program (default: less)'
      ;;
      
    create)
      if [[ -f "$DBH_CONFIG_FILE" ]]; then
        prompt "Configuration file exists. Overwrite? (y/n): "
        read -n 1 confirm
        echo
        [[ "$confirm" != "y" ]] && return 0
      fi
      
      cat > "$DBH_CONFIG_FILE" << 'EOF'
# DBH Configuration File

# MySQL configuration file
DEFAULT_PROFILE=~/.mylocalhost.cnf

# Default database on startup (uncomment to enable)
# DEFAULT_DATABASE=mysql

# Default limit for SELECT queries
DEFAULT_LIMIT=100

# Maximum history entries
MAX_HISTORY=1000

# Pager program
# PAGER=less -S
EOF
      chmod 600 "$DBH_CONFIG_FILE"
      info "Configuration file created at $DBH_CONFIG_FILE"
      ;;
      
    edit)
      local editor="${EDITOR:-vi}"
      if command -v "$editor" >/dev/null 2>&1; then
        [[ ! -f "$DBH_CONFIG_FILE" ]] && handle_cmd_config create
        "$editor" "$DBH_CONFIG_FILE"
        info "Config updated. Reload with '/config reload'."
      else
        error "Editor not found. Set EDITOR or edit manually at $DBH_CONFIG_FILE"
      fi
      ;;
      
    reload)
      load_config
      info "Configuration reloaded from $DBH_CONFIG_FILE"
      ;;
      
    *)
      info 'Usage: /config [show|create|edit|reload]'
      info '  show   - Display current configuration'
      info '  create - Create a default configuration file'
      info '  edit   - Open the configuration file in an editor'
      info '  reload - Reload configuration after manual changes'
      ;;
  esac
  
  return 0
}

handle_cmd_help() {
  info "---------------- $SCRIPT_NAME v$VERSION Help ----------------"
  info " Context: $PromptPrefix"
  
  # Command Type Summary
  info
  info ' Command Types:'
  info '  /command          Slash commands for database operations'
  info '  !command          Shell commands (!alone for interactive shell)'
  info '  SQL               Direct SQL when not starting with / or !'

  # User Interface
  info
  info ' User Interface:'
  info '  Color coding      Prompts, messages, and warnings are color-coded'
  info '  Context-aware     Prompt shows current database and table selection'
  info '  Configurable      Customize via ~/.config/dbh/config'

  # Database Navigation
  info
  info ' Database Navigation:'
  info '  /help             Show available commands'
  info '  /databases        List & select database via menu'
  info '  /database <db>    Directly select database'
  info '  /tables           List & select table via menu'
  info '  /table <n>        Directly select table'
  info '  /.. | /0 | /back  Go back one level (Table->DB->Exit)'
  info '  /q | /quit | /exit Exit the shell'
  
  # Query Building
  info
  info ' Query Building:'
  info "  /columns [cols]   Set columns (Current: $(IFS=,; echo "${SelectedColumns[*]}"))"
  info "  /where [clause]   Set WHERE clause (Current: ${WhereClause:-<None>})"
  info "  /order [cols]     Set ORDER BY (Current: ${OrderClause:-<None>})"
  info "  /asc | /desc      Set direction (Current: $OrderDirection)"
  info "  /limit [num]      Set LIMIT (Current: ${LimitClause:-<None>})"
  info '  /select           Execute query with current state'
  info '  /state            Show query state'

  # Table Operations
  info
  info ' Table Operations:'
  if [[ -n "$DataTable" ]]; then
    info "  /describe         Structure of ${DataTable@Q}"
    info '  /structure [v]    Detailed columns (v=vertical)'
    info "  /status           Status for ${DataTable@Q}"
    info '  /create           CREATE TABLE statement'
    info '  /count            Row count'
    info '  /sample [n]       Show n sample rows (default: 10)'
    info '  /primary-key      Show primary key columns'
    info '  /indexes          Show all indexes'
    info '  /foreign-keys     Show foreign key relationships'
    info '  /find <text>      Search for text in all columns'
    info '  /backup [file]    Backup table to SQL file'
  else
    info '  /describe         Show table structure (requires table)'
    info '  /structure [v]    Detailed column info (v=vertical) (requires table)'
    info '  /status           Show table status (requires table)'
    info '  /create           Show CREATE statement (requires table)'
    info '  /count            Show row count (requires table)'
    info '  /sample [n]       Show n sample rows (requires table)'
    info '  /primary-key      Show primary key columns (requires table)'
    info '  /indexes          Show all indexes (requires table)'
    info '  /foreign-keys     Show foreign key relationships (requires table)'
    info '  /find <text>      Search for text in all columns (requires table)'
    info '  /backup [file]    Backup table to SQL file (requires table)'
  fi
  
  # Database Operations
  info
  info ' Database Operations:'
  info '  /schema [v]       Show database schema with relationships'
  info '  /charset          Show character set information'
  info '  /engines          List available storage engines'
  info '  /backup [file]    Backup current database to SQL file'

  # Administration
  info
  info ' Administration:'
  info '  /whoami           Show current MySQL user and privileges'
  info '  /whois [user]     Show information about a specific MySQL user'
  info '  /users            Show MySQL users and privileges'
  info '  /processes        Show active MySQL processes'
  info '  /variables [filter] Display MySQL system variables'
  info '  /stats            Show database/table statistics'
  info '  /export [file]    Export query results to file (CSV/SQL/JSON)'
  info '  /sql <SQL>        Execute arbitrary SQL'
  info '  /prompt           Open MySQL prompt'

  # Configuration
  info
  info ' Configuration:'
  info '  /config show      Show current settings from ~/.config/dbh/config'
  info '  /config create    Create default configuration file'
  info '  /config edit      Edit configuration in text editor'
  info '  /config reload    Apply changes after editing config file'

  # Shell Access and History
  info
  info ' Shell Access and History:'
  info '  !                 Interactive shell (returns to dbh)'
  info '  !command          Execute shell command'
  info '  ↑/↓               Use arrow keys to navigate history'
  info '  !number           Recall command by history number'
  info '  /history [n]      Show command history (saved across sessions)'

  info '---------------------------------------------------------------'
  return 0
}

handle_cmd_databases() {
  local db REPLY PS3
  local -a dbs
  local db_list_output
  
  # Get list of databases securely
  db_list_output=$(mysql_exec -Nse "SHOW DATABASES;" | sort -i) || { 
    warn "Could not retrieve databases."
    return 1
  }
  
  mapfile -t dbs <<< "$db_list_output"
  if [[ -z "${dbs[*]}" ]]; then 
    info "No databases found (or access denied)."
    return 1
  fi
  
  PS3="$PromptPrefix Select Database (0=cancel, ?=help): "
  echo
  tabs 8
  
  select db in "${dbs[@]}"; do
    REPLY=$(trim "$REPLY")
    case "$REPLY" in 
      q|quit|exit) 
        # Return to main loop instead of exiting program
        info "Database selection cancelled."
        db=''
        break 
        ;;
      0|back) 
        db=''
        break 
        ;;
      \?) 
        handle_cmd_help
        PS3="$PromptPrefix Select Database (0=cancel, ?=help): "
        continue 
        ;;
      *) 
        if [[ -z "$db" && -n "$REPLY" ]]; then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        [[ -n "$db" ]] && break
        ;;
    esac
  done
  
  tabs -8
  
  # Only attempt to set context if a selection was made
  if [[ -n "$db" ]]; then
    set_database_context "$db" || return 1
  else
    return 0  # Return success even when cancelled
  fi
  
  return 0
}

handle_cmd_database() {
  local db_name="$1"; [[ -z "$db_name" ]] && { error "Usage: /database <database_name>"; return 1; }
  set_database_context "$db_name"; return $?
}

handle_cmd_tables() {
  require_database || return 1
  
  local tbl REPLY PS3
  local -a tables
  local table_list_output
  
  # Get list of tables securely
  table_list_output=$(mysql_exec "$Database" -Nse "SHOW TABLES;" | sort -i) || { 
    warn "Could not retrieve tables for ${Database@Q}"
    return 1
  }
  
  mapfile -t tables <<< "$table_list_output"
  if [[ -z "${tables[*]}" ]]; then 
    info "No tables found in ${Database@Q}"
    return 1
  fi
  
  PS3="$PromptPrefix Select Table (0=cancel, ?=help): "
  echo
  tabs 8
  
  select tbl in "${tables[@]}"; do
    REPLY=$(trim "$REPLY")
    case "$REPLY" in 
      q|quit|exit) 
        # Return to main loop instead of exiting program
        info "Table selection cancelled."
        tbl=''
        break 
        ;;
      0|back) 
        tbl=''
        break 
        ;;
      \?) 
        handle_cmd_help
        PS3="$PromptPrefix Select Table (0=cancel, ?=help): "
        continue 
        ;;
      *) 
        if [[ -z "$tbl" && -n "$REPLY" ]]; then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        [[ -n "$tbl" ]] && break
        ;;
    esac
  done
  
  tabs -8
  
  # Only attempt to set context if a selection was made
  if [[ -n "$tbl" ]]; then
    set_table_context "$tbl" || return 1
  else
    return 0  # Return success even when cancelled
  fi
  
  return 0
}

handle_cmd_table() {
  local table_name="$1"
  require_database || return 1
  [[ -z "$table_name" ]] && { error "Usage: /table <table_name>"; return 1; }
  set_table_context "$table_name"; return $?
}

handle_cmd_columns() {
  # Verify we have a database and table selected
  require_table || return 1
  
  # Handle direct input from arguments if provided
  local cols_str="$*"
  if [[ -n "$cols_str" ]]; then
    # Process manually specified columns
    if [[ "$cols_str" == "*" ]]; then
      # Simple case: select all columns
      SelectedColumns=('*')
      info 'Columns set to: *'
    else
      # Parse comma-separated list
      local temp_cols=()
      local i col
      
      # Split by comma, removing spaces
      IFS=',' read -r -a temp_cols <<< "${cols_str//[[:space:]]/}"
      
      # Trim each column
      for i in "${!temp_cols[@]}"; do
        temp_cols[i]=$(trim "${temp_cols[i]}")
      done
      
      # Filter empty entries
      SelectedColumns=()
      for col in "${temp_cols[@]}"; do
        [[ -n "$col" ]] && SelectedColumns+=("$col")
      done
      
      # Check if we have any valid columns
      if ! ((${#SelectedColumns[@]})); then
        error 'Invalid column input. Setting back to *.'
        SelectedColumns=('*')
        return 1
      fi
      
      info "Columns set to: $(IFS=,; echo "${SelectedColumns[*]}")"
    fi
    
    show_select_state
    return 0
  fi
  
  # Show interactive multi-select menu for columns
  # First, get column list from the table
  local column_list_output
  local -a available_columns
  
  # Get column names from the table
  column_list_output=$(mysql_exec "$Database" -Nse "SHOW COLUMNS FROM $(quote_ident "$DataTable") WHERE 1;") || { 
    error "Could not retrieve columns for '$Database.$DataTable'."
    return 1
  }
  
  # Extract just the column names (first column of output)
  column_list_output=$(echo "$column_list_output" | awk '{print $1}')
  
  # Convert to array
  mapfile -t available_columns <<< "$column_list_output"
  
  if [[ -z "${available_columns[*]}" ]]; then 
    error "No columns found in table ${DataTable@Q}"
    return 1
  fi
  
  # Add "* (All columns)" as the first option
  available_columns=("* (All columns)" "${available_columns[@]}")
  
  # Display selection menu
  local PS3 col selected_indices=()
  PS3="$PromptPrefix Select columns (multiple allowed, 0=done, q=cancel, ?=help): "
  
  echo "Current selection: $(IFS=,; echo "${SelectedColumns[*]}")"
  echo "Available columns in $Database.$DataTable:"
  tabs 8
  
  # Interactive selection loop
  while true; do
    # Display the menu with numbers
    echo
    for i in "${!available_columns[@]}"; do
      local mark=' '
      # Check if this column is already selected
      for sel in "${selected_indices[@]}"; do
        if [[ "$sel" == "$i" ]]; then
          mark='X'
          break
        fi
      done
      printf "%3d. [%s] %s\n" "$((i+1))" "$mark" "${available_columns[$i]}"
    done
    
    # Get user selection
    prompt "$PS3"
    read REPLY
    REPLY=$(trim "$REPLY")
    
    case "$REPLY" in
      q|quit|exit) 
        info "Column selection cancelled."
        tabs -8
        return 1 
        ;;
      0|done) 
        break 
        ;;
      \?)
        echo 'Use numbers to select columns, multiple selections allowed.'
        echo "Enter 0 or 'done' when finished, q to cancel."
        continue 
        ;;
      [0-9]*) 
        # Convert to zero-based index
        local idx=$((REPLY-1))
        if ((idx < 0 || idx >= ${#available_columns[@]})); then
          warn "Invalid selection: $REPLY"
          continue
        fi
        
        # Check if this index is already selected
        local found=0
        for i in "${!selected_indices[@]}"; do
          if [[ "${selected_indices[$i]}" == "$idx" ]]; then
            # Remove from selection (toggle)
            unset 'selected_indices[$i]'
            found=1
            info "Removed ${available_columns[$idx]} from selection"
            # Re-index the array
            selected_indices=("${selected_indices[@]}")
            break
          fi
        done
        
        if ! ((found)); then
          # Special case for "* (All columns)" - clear other selections
          if ! ((idx)); then
            selected_indices=(0)
            info "Selected all columns (*)"
          else
            # If we have "*" and adding a specific column, remove the "*"
            if [[ " ${selected_indices[*]} " == *" 0 "* ]]; then
              selected_indices=()
            fi
            # Add to selection
            selected_indices+=("$idx")
            info "Added ${available_columns[$idx]} to selection"
          fi
        fi
        ;;
      *) 
        warn "Invalid input: $REPLY"
        ;;
    esac
  done
  
  tabs -8
  
  # No selection means select all columns
  if ! ((${#selected_indices[@]})); then
    SelectedColumns=('*')
    info 'No columns selected, defaulting to all columns (*)'
  else
    # Process the selections into actual column names
    SelectedColumns=()
    for idx in "${selected_indices[@]}"; do
      if ! ((idx)); then
        # Special case for "* (All columns)"
        SelectedColumns=('*')
        break
      else
        SelectedColumns+=("${available_columns[$idx]}")
      fi
    done
  fi
  
  # Show final selection
  if [[ "${SelectedColumns[*]}" == "*" ]]; then
    info 'Columns set to: * (All columns)'
  else
    info "Columns set to: $(IFS=,; echo "${SelectedColumns[*]}")"
  fi
  
  show_select_state
  return 0
}

handle_cmd_where() {
  local where_input="$*"; if ! (($#)); then prompt "WHERE clause (blank to clear): "; read -e -i "$WhereClause" where_input; where_input=$(trim "$where_input"); fi
  WhereClause="$where_input"; info "WHERE clause set to: ${WhereClause:-<None>}"; show_select_state; return 0
}

handle_cmd_order() {
  local order_input="$*"; if ! (($#)); then prompt "ORDER BY column(s) (blank to clear): "; read -e -i "$OrderClause" order_input; order_input=$(trim "$order_input"); fi
  OrderClause="$order_input"; info "ORDER BY clause set to: ${OrderClause:-<None>}"; show_select_state; return 0
}

handle_cmd_limit() {
  local limit_input=''; if (($# == 1)) && [[ -n "$1" ]]; then limit_input="$1"; elif (($# != 1)); then prompt "LIMIT (number or blank to clear): "; read -e -i "$LimitClause" limit_input; limit_input=$(trim "$limit_input"); elif (($# == 1)) && [[ -z "$1" ]]; then prompt "LIMIT (number or blank to clear): "; read -e -i "$LimitClause" limit_input; limit_input=$(trim "$limit_input"); fi
  if [[ -z "$limit_input" ]]; then LimitClause=''; info 'LIMIT cleared.'; elif [[ "$limit_input" =~ ^[0-9]+$ ]]; then LimitClause="$limit_input"; info "LIMIT set to: $LimitClause"; else error "Invalid LIMIT value '$limit_input'. Must be a positive number."; return 1; fi
  show_select_state; return 0
}

handle_cmd_asc_desc() {
  local direction="$1"; if [[ "${direction,,}" == 'desc' ]]; then OrderDirection='DESC'; info 'ORDER BY direction set to DESC.'; else OrderDirection='ASC'; info 'ORDER BY direction set to ASC.'; fi
  show_select_state; return 0
}

handle_cmd_select() {
  # Verify context requirements
  require_table "No table selected (/table)." || return 1
  
  # Build SQL query safely
  local sql='SELECT '

  # Handle column selection
  if [[ "${SelectedColumns[*]}" == '*' ]]; then
    sql+='*'
  else
    local quoted_cols=()
    local col
    for col in "${SelectedColumns[@]}"; do
      # Quote each column identifier
      quoted_cols+=("$(quote_ident "$col")")
    done
    sql+=$(IFS=,; echo "${quoted_cols[*]}")
  fi
  
  # Add table name (safely quoted)
  sql+=" FROM $(quote_ident "$DataTable")"
  
  # Add WHERE clause if specified (user is responsible for proper where clause syntax)
  if [[ -n "$WhereClause" ]]; then
    # Note: WhereClause is not auto-escaped as it may contain complex conditions
    # Users must be careful with this
    sql+=" WHERE $WhereClause"
  fi
  
  # Add ORDER BY if specified
  if [[ -n "$OrderClause" ]]; then
    # Split order clause by commas and quote each part
    local order_parts
    IFS=',' read -ra order_parts <<< "$OrderClause"
    local quoted_order_parts=()
    local part
    for part in "${order_parts[@]}"; do
      quoted_order_parts+=("$(quote_ident "$(trim "$part")")")
    done
    sql+=" ORDER BY $(IFS=,; echo "${quoted_order_parts[*]}") $OrderDirection"
  fi
  
  # Add LIMIT if specified
  if [[ -n "$LimitClause" ]]; then
    # Ensure limit is numeric
    if [[ "$LimitClause" =~ ^[0-9]+$ ]]; then
      sql+=" LIMIT $LimitClause"
    else
      error "Invalid LIMIT value: $LimitClause (must be numeric)"
      return 1
    fi
  fi
  
  # Execute the query
  info "Executing: $sql"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    {
      # Use table format with paging through less
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "$sql" | less -RS
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    }
  else
    # Use table format without paging if less isn't available
    mysql_run_display "$Database" --table -e "$sql"
  fi
  
  return $?
}

handle_cmd_desc() {
  require_table || return 1
  
  info "Structure for '$Database.$DataTable':"
  mysql_exec "$Database" -e "DESCRIBE $(quote_ident "$DataTable");" || return 1
  return 0
}

handle_cmd_structure() {
  require_table || return 1
  
  local format="$1"
  local quoted_table
  quoted_table=$(quote_ident "$DataTable")
  
  # Check if less is available
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  info "Detailed structure for '$Database.$DataTable':"
  
  # Determine format and pager options
  if [[ "$format" == "v" ]]; then
    # Vertical format
    if (( use_pager )); then
      # Use less with raw control chars (-R) and no line wrapping (-S)
      { 
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          -e "SHOW FULL COLUMNS FROM $quoted_table\G" | less -RS
        # Reset terminal after using less
        stty sane 2>/dev/null || true
      }
    else
      # Direct output without pager
      mysql_exec "$Database" -e "SHOW FULL COLUMNS FROM $quoted_table\G" || return 1
    fi
  else
    # Boxed tabular format
    if (( use_pager )); then
      # Use less with raw control chars (-R) and no line wrapping (-S)
      {
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "SHOW FULL COLUMNS FROM $quoted_table;" | less -RS
        # Reset terminal after using less
        stty sane 2>/dev/null || true
      }
    else
      # Direct output without pager but still boxed
      mysql_exec "$Database" --table -e "SHOW FULL COLUMNS FROM $quoted_table;" || return 1
    fi
  fi
  
  return 0
}

handle_cmd_status() {
  require_table || return 1
  
  info "Status for '$Database.$DataTable':"
  mysql_exec "$Database" -e "SHOW TABLE STATUS WHERE Name = $(escape_sql_value "$DataTable")\G" || return 1
  return 0
}

handle_cmd_create() {
  require_table || return 1
  
  info "CREATE TABLE statement for '$Database.$DataTable':"
  local create_statement
  create_statement=$(mysql_exec "$Database" -sN -e "SHOW CREATE TABLE $(quote_ident "$DataTable");") || return 1
  
  if [[ -n "$create_statement" ]]; then
    echo "$create_statement" | cut -f2-
  else
    error 'Could not parse CREATE output.'
    return 1
  fi
  
  return 0
}

handle_cmd_count() {
  require_table || return 1
  
  local count
  count=$(mysql_exec "$Database" -Nse "SELECT COUNT(*) FROM $(quote_ident "$DataTable");") || return 1
  info "Row count for '$Database.$DataTable': $count"
  return 0
}

handle_cmd_sql() {
  local sql_command="$*"
  
  require_database "No database selected (/database)." || return 1
  
  if [[ -z "$sql_command" ]]; then
    error 'Usage: /sql <SQL query...>'
    return 1
  fi
  
  # Display warning for potentially destructive operations
  if [[ "$sql_command" =~ ^[[:space:]]*(DROP|DELETE|TRUNCATE|UPDATE|ALTER)[[:space:]] ]]; then
    warn "Executing potentially destructive operation: $sql_command"
    prompt "Are you sure you want to continue? (y/N): "
    read -n 1 -r confirm
    echo
    if [[ ! $confirm =~ ^[Yy]$ ]]; then
      info "Operation cancelled."
      return 0
    fi
  fi
  
  info "Executing SQL in ${Database@Q}: $sql_command"
  mysql_exec "$Database" -e "$sql_command"
  return $?
}

handle_cmd_prompt() {
  require_database "No database selected (/database)." || return 1
  info "Launching interactive MySQL prompt for database ${Database@Q}..."; info "Type 'exit' or 'quit' to return to $SCRIPT_NAME."; stty sane
  if ! mysql --defaults-file="$PROFILE" --no-auto-rehash --prompt="[$SCRIPT_NAME:$Database] mysql> " "$Database"; then error "MySQL interactive session exited."; fi
  stty sane; clear; info "Returned to $SCRIPT_NAME. Current context: $PromptPrefix"; bind '"\e[0n": redraw-current-line'; printf '\e[0n' > /dev/tty; return 0
}

# Display sample rows from the current table
handle_cmd_sample() {
  require_table || return 1

  local num_rows='10' # Default number of rows
  local quoted_table
  quoted_table=$(quote_ident "$DataTable")
  
  # Parse argument for number of rows if provided
  if [[ -n "$1" && "$1" =~ ^[0-9]+$ ]]; then
    num_rows="$1"
  elif [[ -n "$1" && ! "$1" =~ ^[0-9]+$ ]]; then
    warn "Invalid number of rows ${1@Q}. Using default ($num_rows)."
  fi
  
  info "Showing $num_rows sample rows from '$Database.$DataTable':"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    {
      # Use table format with paging through less
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "SELECT * FROM $quoted_table LIMIT $num_rows;" | less -RS
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    }
  else
    # Use table format without paging if less isn't available
    mysql_run_display "$Database" --table -e "SELECT * FROM $quoted_table LIMIT $num_rows;"
  fi
  
  return $?
}

# Show primary key information for the current table
handle_cmd_primary_key() {
  require_table || return 1
  
  info "Primary key for '$Database.$DataTable':"
  
  local query
  query="SELECT k.COLUMN_NAME, c.DATA_TYPE, c.COLUMN_TYPE, k.CONSTRAINT_NAME 
         FROM information_schema.TABLE_CONSTRAINTS tc 
         JOIN information_schema.KEY_COLUMN_USAGE k USING(CONSTRAINT_NAME, TABLE_SCHEMA, TABLE_NAME) 
         JOIN information_schema.COLUMNS c ON c.TABLE_SCHEMA = k.TABLE_SCHEMA 
                                          AND c.TABLE_NAME = k.TABLE_NAME 
                                          AND c.COLUMN_NAME = k.COLUMN_NAME
         WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY' 
           AND tc.TABLE_SCHEMA = $(escape_sql_value "$Database") 
           AND tc.TABLE_NAME = $(escape_sql_value "$DataTable")
         ORDER BY k.ORDINAL_POSITION;"
  
  local result
  result=$(mysql_exec "$Database" --table -e "$query")
  local exit_code=$?
  
  if ! ((exit_code)); then
    if [[ -z "$result" ]]; then
      info "No primary key defined for table ${DataTable@Q}"
    else
      echo "$result"
    fi
  fi

  return $exit_code
}

# Show all indexes for the current table
handle_cmd_indexes() {
  require_table || return 1
  
  info "Indexes for '$Database.$DataTable':"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  local quoted_table
  quoted_table=$(quote_ident "$DataTable")
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    {
      # Use table format with paging through less
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "SHOW INDEX FROM $quoted_table;" | less -RS
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    }
  else
    # Direct output without pager
    mysql_exec "$Database" --table -e "SHOW INDEX FROM $quoted_table;"
  fi
  
  return $?
}

# Search table data for specific text
handle_cmd_find() {
  require_table || return 1
  
  local search_text="$*"
  if [[ -z "$search_text" ]]; then
    prompt "Enter text to search for: "
    read -e search_text
    if [[ -z "$search_text" ]]; then
      error 'No search text provided.'
      return 1
    fi
  fi
  
  info "Searching for ${search_text@Q} in '$Database.$DataTable':"
  
  # Get column list from the table for building query
  local column_list
  column_list=$(mysql_exec "$Database" -Nse "SHOW COLUMNS FROM $(quote_ident "$DataTable") WHERE 1;") || { 
    error "Could not retrieve columns for '$Database.$DataTable'."
    return 1
  }
  
  # Extract just the column names (first column of output)
  local columns
  mapfile -t columns < <(echo "$column_list" | awk '{print $1}')
  
  if ! ((${#columns[@]})); then
    error "No columns found in table ${DataTable@Q}"
    return 1
  fi
  
  # Build LIKE conditions for each column
  local conditions=()
  local col
  local quoted_col
  for col in "${columns[@]}"; do
    quoted_col=$(quote_ident "$col")
    # Only apply LIKE to string-like columns (VARCHAR, TEXT, etc.)
    # For non-string columns, use string conversion
    conditions+=("CAST($quoted_col AS CHAR) LIKE CONCAT('%', $(escape_sql_value "$search_text"), '%')")
  done
  
  # Combine all conditions with OR
  local where_clause
  where_clause=$(IFS=" OR "; echo "${conditions[*]}")
  
  # Execute the search query
  local query
  query="SELECT * FROM $(quote_ident "$DataTable") WHERE $where_clause LIMIT 100;"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    {
      # Use table format with paging through less
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "$query" | less -RS
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    }
  else
    # Use table format without paging
    mysql_run_display "$Database" --table -e "$query"
  fi
  
  return $?
}

# Display command history
handle_cmd_history() {
  local count=20 # Default number of history items to show
  
  # Parse argument for number of items if provided
  if [[ -n "$1" && "$1" =~ ^[0-9]+$ ]]; then
    count="$1"
  elif [[ -n "$1" && ! "$1" =~ ^[0-9]+$ ]]; then
    warn "Invalid count ${1@Q}. Using default ($count)."
  fi
  
  # Display history file info
  if [[ -r "$DBH_HISTORY_FILE" ]]; then
    info "Command history from $DBH_HISTORY_FILE (total entries: ${#CommandHistory[@]}):"
  else
    info "Command history (total entries: ${#CommandHistory[@]}):"
  fi
  
  # Use the built-in history command if no CommandHistory array
  if ! ((${#CommandHistory[@]})); then
    info "No command history found."
    # Use built-in bash history command as fallback
    history "$count"
  else
    # Use our tracked history
    # Calculate start position
    local start=$((${#CommandHistory[@]} > count ? ${#CommandHistory[@]} - count : 0))
    # Show last count entries (or all if fewer)
    for ((i=start; i<${#CommandHistory[@]}; i+=1)); do
      printf "%3d  %s\n" $((i+1)) "${CommandHistory[$i]}"
    done
  fi
  
  echo
  info 'To navigate history:'
  info '- Use UP/DOWN arrow keys to scroll through commands'
  info '- Use !N to execute command number N (e.g., !5)'
  info 'History is persistent across sessions'
  
  return 0
}

# Show database schema with table relationships
handle_cmd_schema() {
  require_database || return 1
  
  local format="$1"
  local vertical_format=0
  
  if [[ "$format" == "v" ]]; then
    vertical_format=1
  fi
  
  info "Database schema for ${Database@Q}:"
  
  # First, get a list of all tables
  local tables_list
  tables_list=$(mysql_exec "$Database" -Nse "SHOW TABLES;" | sort -i) || { 
    error "Could not retrieve tables for ${Database@Q}"
    return 1
  }
  
  if [[ -z "$tables_list" ]]; then
    info "No tables found in ${Database@Q}"
    return 0
  fi
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Build query to get foreign key relationships
  local query
  query="SELECT 
           tc.TABLE_NAME as 'Table',
           tc.CONSTRAINT_NAME as 'Constraint Name',
           kcu.COLUMN_NAME as 'Column',
           kcu.REFERENCED_TABLE_NAME as 'Referenced Table',
           kcu.REFERENCED_COLUMN_NAME as 'Referenced Column'
         FROM information_schema.TABLE_CONSTRAINTS tc
         JOIN information_schema.KEY_COLUMN_USAGE kcu 
           ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
           AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
         WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY'
         AND tc.TABLE_SCHEMA = $(escape_sql_value "$Database")
         ORDER BY tc.TABLE_NAME, kcu.ORDINAL_POSITION;"
  
  # Execute with appropriate formatting and paging
  if (( vertical_format )); then
    # Vertical format
    if (( use_pager )); then
      local schema_file
      schema_file=$(create_secure_tempfile "${SCRIPT_NAME}.schema")
      
      {
        # Introduction
        echo "Foreign key relationships in database ${Database@Q}:"
        echo "-------------------------------------------------"
        echo
        
        # Execute the query with vertical format
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          -e "$query\G"
      } > "$schema_file"
      
      # Use less directly on the file
      less -RS "$schema_file"
      
      # Clean up
      rm -f "$schema_file"
      
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    else
      # Direct output without pager
      echo "Foreign key relationships in database ${Database@Q}:"
      echo "-------------------------------------------------"
      echo
      mysql_exec "$Database" -e "$query\G"
    fi
  else
    # Tabular format
    if (( use_pager )); then
      local schema_file
      schema_file=$(create_secure_tempfile "${SCRIPT_NAME}.schema")
      
      {
        # Introduction
        echo "Foreign key relationships in database ${Database@Q}:"
        echo "-------------------------------------------------"
        echo
        
        # Execute the query with table format
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query"
      } > "$schema_file"
      
      # Use less directly on the file
      less -RS "$schema_file"
      
      # Clean up
      rm -f "$schema_file"
      
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    else
      # Direct output without pager
      echo "Foreign key relationships in database ${Database@Q}:"
      echo "-------------------------------------------------"
      echo
      mysql_exec "$Database" --table -e "$query"
    fi
  fi
  
  # Now show a summary of tables without foreign keys
  local query_tables_without_fk
  query_tables_without_fk="SELECT
                             t.TABLE_NAME as 'Table Without Foreign Keys'
                           FROM information_schema.TABLES t
                           LEFT JOIN (
                             SELECT DISTINCT tc.TABLE_NAME
                             FROM information_schema.TABLE_CONSTRAINTS tc
                             WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY'
                             AND tc.TABLE_SCHEMA = $(escape_sql_value "$Database")
                           ) fk ON t.TABLE_NAME = fk.TABLE_NAME
                           WHERE t.TABLE_SCHEMA = $(escape_sql_value "$Database")
                           AND fk.TABLE_NAME IS NULL
                           ORDER BY t.TABLE_NAME;"
  
  echo
  echo "Tables without foreign key relationships:"
  echo "----------------------------------------"
  mysql_exec "$Database" --table -e "$query_tables_without_fk"
  
  return 0
}

# Show foreign key relationships for the current table
handle_cmd_foreign_keys() {
  if [[ -z "$DataTable" ]]; then
    error "No table selected. Use /table first."
    return 1
  fi
  
  info "Foreign key relationships for '$Database.$DataTable':"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Build query to find foreign keys in this table
  local query_fk_out
  query_fk_out="SELECT 
                  kcu.CONSTRAINT_NAME as 'Constraint Name',
                  kcu.COLUMN_NAME as 'Column',
                  kcu.REFERENCED_TABLE_NAME as 'Referenced Table',
                  kcu.REFERENCED_COLUMN_NAME as 'Referenced Column'
                FROM information_schema.TABLE_CONSTRAINTS tc
                JOIN information_schema.KEY_COLUMN_USAGE kcu 
                  ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
                  AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
                WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY'
                AND tc.TABLE_SCHEMA = $(escape_sql_value "$Database")
                AND tc.TABLE_NAME = $(escape_sql_value "$DataTable")
                ORDER BY kcu.ORDINAL_POSITION;"
  
  # Build query to find tables referencing this table
  local query_fk_in
  query_fk_in="SELECT 
                 tc.TABLE_NAME as 'Referencing Table',
                 kcu.COLUMN_NAME as 'Referencing Column',
                 kcu.CONSTRAINT_NAME as 'Constraint Name',
                 kcu.REFERENCED_COLUMN_NAME as 'Referenced Column'
               FROM information_schema.TABLE_CONSTRAINTS tc
               JOIN information_schema.KEY_COLUMN_USAGE kcu 
                 ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
                 AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
               WHERE tc.CONSTRAINT_TYPE = 'FOREIGN KEY'
               AND tc.TABLE_SCHEMA = $(escape_sql_value "$Database")
               AND kcu.REFERENCED_TABLE_NAME = $(escape_sql_value "$DataTable")
               ORDER BY tc.TABLE_NAME, kcu.ORDINAL_POSITION;"
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local fk_file
    fk_file=$(create_secure_tempfile "${SCRIPT_NAME}.fk")
    
    {
      echo "Foreign keys FROM this table to other tables:"
      echo "-------------------------------------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "$query_fk_out"
      
      echo
      echo "Foreign keys TO this table from other tables:"
      echo "-------------------------------------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        --table -e "$query_fk_in"
    } > "$fk_file"
    
    # Use less directly on the file
    less -RS "$fk_file"
    
    # Clean up
    rm -f "$fk_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    echo "Foreign keys FROM this table to other tables:"
    echo "-------------------------------------------"
    mysql_exec "$Database" --table -e "$query_fk_out" 
    
    echo
    echo "Foreign keys TO this table from other tables:"
    echo "-------------------------------------------"
    mysql_exec "$Database" --table -e "$query_fk_in"
  fi
  
  return 0
}

# Create a backup of current table or database
handle_cmd_backup() {
  local output_file="$1"
  local current_time
  current_time=$(date +"%Y%m%d_%H%M%S")
  
  require_database || return 1
  
  # Determine what to backup (table or database)
  local backup_type='database'
  local backup_name="$Database"

  if [[ -n "$DataTable" ]]; then
    backup_type='table'
    backup_name="$Database.$DataTable"
  fi
  
  # Default filename if not provided
  if [[ -z "$output_file" ]]; then
    if [[ "$backup_type" == 'table' ]]; then
      output_file="${Database}_${DataTable}_${current_time}.sql"
    else
      output_file="${Database}_${current_time}.sql"
    fi
  fi
  
  # Check if mysqldump is available
  if ! command -v mysqldump > /dev/null; then
    error 'mysqldump command not found. Cannot create backup.'
    return 1
  fi
  
  info "Creating backup of $backup_type ${backup_name@Q} to file ${output_file@Q}..."

  # Build mysqldump command as array for safe execution
  local -a dump_cmd=(mysqldump "--defaults-file=$PROFILE" --add-drop-table --routines --triggers "$Database")

  # Add table option if backing up a specific table
  if [[ -n "$DataTable" ]]; then
    dump_cmd+=(--tables "$DataTable")
  fi

  # Execute the dump command
  if "${dump_cmd[@]}" > "$output_file"; then
    success "Backup completed successfully to ${output_file@Q}"
    info "File size: $(du -h "$output_file" | cut -f1)"
  else
    error "Backup failed with status $?."
    return 1
  fi
  
  return 0
}

# Show character set information
handle_cmd_charset() {
  info "Character Set Information:"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  local target="server"
  local query_server="SHOW VARIABLES LIKE 'character\\_set\\_%';"
  local query_db=''
  local query_table=''
  
  # If a database is selected, also show database charset
  if [[ -n "$Database" ]]; then
    target="database $Database"
    query_db="SELECT DEFAULT_CHARACTER_SET_NAME as 'Database Character Set'
              FROM information_schema.SCHEMATA 
              WHERE SCHEMA_NAME = $(escape_sql_value "$Database");"
  fi
  
  # If a table is selected, also show table and column charset
  if [[ -n "$DataTable" ]]; then
    target="table $Database.$DataTable"
    query_table="SELECT CCSA.character_set_name as 'Table Character Set'
                 FROM information_schema.TABLES T
                 JOIN information_schema.COLLATION_CHARACTER_SET_APPLICABILITY CCSA
                 ON T.TABLE_COLLATION = CCSA.COLLATION_NAME
                 WHERE T.TABLE_SCHEMA = $(escape_sql_value "$Database")
                 AND T.TABLE_NAME = $(escape_sql_value "$DataTable");"
    
    query_columns="SELECT COLUMN_NAME as 'Column',
                        CHARACTER_SET_NAME as 'Character Set',
                        COLLATION_NAME as 'Collation'
                 FROM information_schema.COLUMNS
                 WHERE TABLE_SCHEMA = $(escape_sql_value "$Database")
                 AND TABLE_NAME = $(escape_sql_value "$DataTable")
                 AND CHARACTER_SET_NAME IS NOT NULL;"
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local charset_file
    charset_file=$(create_secure_tempfile "${SCRIPT_NAME}.charset")
    
    {
      echo "Character Set Information for $target:"
      echo "--------------------------------------"
      echo
      
      echo "Server Character Sets:"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "$query_server"
      
      if [[ -n "$query_db" ]]; then
        echo
        echo "Database Character Set:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_db"
      fi
      
      if [[ -n "$query_table" ]]; then
        echo
        echo "Table Character Set:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_table"
        
        echo
        echo "Column Character Sets:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query_columns"
      fi
    } > "$charset_file"
    
    # Use less directly on the file
    less -RS "$charset_file"
    
    # Clean up
    rm -f "$charset_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    echo "Character Set Information for $target:"
    echo "--------------------------------------"
    echo
    
    echo "Server Character Sets:"
    mysql_exec --table -e "$query_server"
    
    if [[ -n "$query_db" ]]; then
      echo
      echo "Database Character Set:"
      mysql_exec --table -e "$query_db"
    fi
    
    if [[ -n "$query_table" ]]; then
      echo
      echo "Table Character Set:"
      mysql_exec --table -e "$query_table"
      
      echo
      echo "Column Character Sets:"
      mysql_exec "$Database" --table -e "$query_columns"
    fi
  fi
  
  return 0
}

# List available storage engines
handle_cmd_engines() {
  info "Available Storage Engines:"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local engines_file
    engines_file=$(create_secure_tempfile "${SCRIPT_NAME}.engines")
    
    # Output to temp file
    mysql --defaults-file="$PROFILE" --no-auto-rehash \
      --table -e "SHOW ENGINES;" > "$engines_file"
    
    # Use less directly on the file
    less -RS "$engines_file"
    
    # Clean up
    rm -f "$engines_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    mysql_exec --table -e "SHOW ENGINES;"
  fi
  
  # If a database is selected, show engine usage
  if [[ -n "$Database" ]]; then
    echo
    echo "Storage engines used in database ${Database@Q}:"
    
    local query_engines
    query_engines="SELECT 
                     TABLE_NAME as 'Table',
                     ENGINE as 'Storage Engine'
                   FROM information_schema.TABLES
                   WHERE TABLE_SCHEMA = $(escape_sql_value "$Database")
                   ORDER BY ENGINE, TABLE_NAME;"
    
    mysql_exec --table -e "$query_engines"
    
    # Show engine counts
    echo
    echo "Engine usage summary:"
    
    local query_summary
    query_summary="SELECT 
                     ENGINE as 'Storage Engine',
                     COUNT(*) as 'Number of Tables'
                   FROM information_schema.TABLES
                   WHERE TABLE_SCHEMA = $(escape_sql_value "$Database")
                   GROUP BY ENGINE
                   ORDER BY COUNT(*) DESC;"
    
    mysql_exec --table -e "$query_summary"
  fi
  
  return 0
}

# Show information about a specified MySQL user
handle_cmd_whois() {
  local user_input="$*"
  local user_name
  local host_name
  
  # Default to current user if no user specified
  if [[ -z "$user_input" ]]; then
    user_input=$(mysql_exec -Nse "SELECT CURRENT_USER();")
    info "No user specified, using current user: $user_input"
  fi
  
  # Parse user@host format
  if [[ "$user_input" == *"@"* ]]; then
    user_name="${user_input%%@*}"
    host_name="${user_input##*@}"
  else
    user_name="$user_input"
    host_name="%"  # Match any host if not specified
  fi
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local whois_file
    whois_file=$(create_secure_tempfile "${SCRIPT_NAME}.whois")
    
    {
      echo "User Information for ${user_name@Q}@${host_name@Q}:"
      echo "-----------------------------------------"
      echo
      
      # Get basic user info
      echo "User Accounts:"
      echo "-------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "SELECT 
                  User, 
                  Host, 
                  IF(plugin='mysql_native_password','Native Password',
                    IF(plugin='caching_sha2_password','SHA-2 Password', plugin)) AS 'Auth Method',
                  Account_locked AS 'Locked',
                  Password_expired AS 'Password Expired'
                FROM mysql.user
                WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
                ORDER BY User, Host;"
      
      # Get global grants
      echo
      echo "Global Privileges:"
      echo "----------------"
      
      local query_global_privs
      query_global_privs="SHOW GRANTS FOR '${user_name}'@'${host_name}';"
      
      # Safely try to show grants, but don't error if we don't have permission
      if ! mysql --defaults-file="$PROFILE" --no-auto-rehash \
           --table -e "$query_global_privs" 2>/dev/null; then
        echo "ERROR: Unable to show grants for '${user_name}'@'${host_name}'"
        echo "This may be due to insufficient privileges or the user does not exist."
      fi
      
      # Get database-specific privileges
      echo
      echo "Database-Specific Privileges:"
      echo "---------------------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "SELECT 
                  Db AS 'Database',
                  CONCAT(
                    IF(Select_priv='Y','SELECT,',''),
                    IF(Insert_priv='Y','INSERT,',''),
                    IF(Update_priv='Y','UPDATE,',''),
                    IF(Delete_priv='Y','DELETE,',''),
                    IF(Create_priv='Y','CREATE,',''),
                    IF(Drop_priv='Y','DROP,',''),
                    IF(Grant_priv='Y','GRANT,',''),
                    IF(References_priv='Y','REFERENCES,',''),
                    IF(Index_priv='Y','INDEX,',''),
                    IF(Alter_priv='Y','ALTER,',''),
                    IF(Create_tmp_table_priv='Y','CREATE_TMP,',''),
                    IF(Lock_tables_priv='Y','LOCK TABLES,',''),
                    IF(Create_view_priv='Y','CREATE VIEW,',''),
                    IF(Show_view_priv='Y','SHOW VIEW,',''),
                    IF(Create_routine_priv='Y','CREATE ROUTINE,',''),
                    IF(Alter_routine_priv='Y','ALTER ROUTINE,',''),
                    IF(Execute_priv='Y','EXECUTE,','')
                  ) AS 'Database Privileges'
                FROM mysql.db
                WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
                ORDER BY Db;"
      
      # Get table-specific privileges
      echo
      echo "Table-Specific Privileges:"
      echo "------------------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "SELECT 
                  Db AS 'Database',
                  Table_name AS 'Table',
                  CONCAT(
                    IF(Table_priv & 1,'SELECT,',''),
                    IF(Table_priv & 2,'INSERT,',''),
                    IF(Table_priv & 4,'UPDATE,',''),
                    IF(Table_priv & 8,'DELETE,',''),
                    IF(Table_priv & 16,'CREATE,',''),
                    IF(Table_priv & 32,'DROP,',''),
                    IF(Table_priv & 64,'GRANT,',''),
                    IF(Table_priv & 128,'REFERENCES,',''),
                    IF(Table_priv & 256,'INDEX,',''),
                    IF(Table_priv & 512,'ALTER,','')
                  ) AS 'Table Privileges'
                FROM mysql.tables_priv
                WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
                ORDER BY Db, Table_name;"
    } > "$whois_file"
    
    # Use less directly on the file
    less -RS "$whois_file"
    
    # Clean up
    rm -f "$whois_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    echo "User Information for '$user_name'@'$host_name':"
    echo "-----------------------------------------"
    echo
    
    # Get basic user info
    echo "User Accounts:"
    echo "-------------"
    mysql_exec --table -e "SELECT 
                User, 
                Host, 
                IF(plugin='mysql_native_password','Native Password',
                  IF(plugin='caching_sha2_password','SHA-2 Password', plugin)) AS 'Auth Method',
                Account_locked AS 'Locked',
                Password_expired AS 'Password Expired'
              FROM mysql.user
              WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
              ORDER BY User, Host;"
    
    # Get global grants
    echo
    echo "Global Privileges:"
    echo "----------------"
    
    local query_global_privs
    query_global_privs="SHOW GRANTS FOR '${user_name}'@'${host_name}';"
    
    # Safely try to show grants, but don't error if we don't have permission
    if ! mysql_exec --table -e "$query_global_privs" 2>/dev/null; then
      echo "ERROR: Unable to show grants for '${user_name}'@'${host_name}'"
      echo "This may be due to insufficient privileges or the user does not exist."
    fi
    
    # Get database-specific privileges
    echo
    echo "Database-Specific Privileges:"
    echo "---------------------------"
    mysql_exec --table -e "SELECT 
                Db AS 'Database',
                CONCAT(
                  IF(Select_priv='Y','SELECT,',''),
                  IF(Insert_priv='Y','INSERT,',''),
                  IF(Update_priv='Y','UPDATE,',''),
                  IF(Delete_priv='Y','DELETE,',''),
                  IF(Create_priv='Y','CREATE,',''),
                  IF(Drop_priv='Y','DROP,',''),
                  IF(Grant_priv='Y','GRANT,',''),
                  IF(References_priv='Y','REFERENCES,',''),
                  IF(Index_priv='Y','INDEX,',''),
                  IF(Alter_priv='Y','ALTER,',''),
                  IF(Create_tmp_table_priv='Y','CREATE_TMP,',''),
                  IF(Lock_tables_priv='Y','LOCK TABLES,',''),
                  IF(Create_view_priv='Y','CREATE VIEW,',''),
                  IF(Show_view_priv='Y','SHOW VIEW,',''),
                  IF(Create_routine_priv='Y','CREATE ROUTINE,',''),
                  IF(Alter_routine_priv='Y','ALTER ROUTINE,',''),
                  IF(Execute_priv='Y','EXECUTE,','')
                ) AS 'Database Privileges'
              FROM mysql.db
              WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
              ORDER BY Db;"
    
    # Get table-specific privileges
    echo
    echo "Table-Specific Privileges:"
    echo "------------------------"
    mysql_exec --table -e "SELECT 
                Db AS 'Database',
                Table_name AS 'Table',
                CONCAT(
                  IF(Table_priv & 1,'SELECT,',''),
                  IF(Table_priv & 2,'INSERT,',''),
                  IF(Table_priv & 4,'UPDATE,',''),
                  IF(Table_priv & 8,'DELETE,',''),
                  IF(Table_priv & 16,'CREATE,',''),
                  IF(Table_priv & 32,'DROP,',''),
                  IF(Table_priv & 64,'GRANT,',''),
                  IF(Table_priv & 128,'REFERENCES,',''),
                  IF(Table_priv & 256,'INDEX,',''),
                  IF(Table_priv & 512,'ALTER,','')
                ) AS 'Table Privileges'
              FROM mysql.tables_priv
              WHERE User LIKE '${user_name}' AND Host LIKE '${host_name}'
              ORDER BY Db, Table_name;"
  fi
  
  return 0
}

# Show current MySQL user
handle_cmd_whoami() {
  info "Current MySQL user:"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local whoami_file
    whoami_file=$(create_secure_tempfile "${SCRIPT_NAME}.whoami")
    
    {
      echo "Current MySQL User:"
      echo "------------------"
      echo
      
      # Query to get current user and host with table format
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "SELECT USER() AS 'Current User', CURRENT_USER() AS 'Effective User';"
      
      # If a database is selected, also show privileges
      if [[ -n "$Database" ]]; then
        echo
        echo "Privileges for current user:"
        echo "--------------------------"
        
        local query_privs
        query_privs="SHOW GRANTS FOR CURRENT_USER();"
        
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_privs"
          
        # Additional database-specific privileges if available
        if mysql --defaults-file="$PROFILE" --no-auto-rehash information_schema -e "SELECT 1 FROM TABLES WHERE 1=0" &>/dev/null; then
          echo
          echo "Database-specific privileges for current user:"
          echo "------------------------------------------"
          
          mysql --defaults-file="$PROFILE" --no-auto-rehash \
            --table -e "SELECT PRIVILEGE_TYPE, IS_GRANTABLE 
                      FROM information_schema.USER_PRIVILEGES 
                      WHERE GRANTEE LIKE CONCAT(\"'%\", SUBSTRING_INDEX(CURRENT_USER(), '@', 1), \"%'\") 
                      ORDER BY PRIVILEGE_TYPE;"
        fi
      fi
    } > "$whoami_file"
    
    # Use less directly on the file
    less -RS "$whoami_file"
    
    # Clean up
    rm -f "$whoami_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    echo "Current MySQL User:"
    echo "------------------"
    echo
    
    # Query to get current user and host with table format
    mysql_exec --table -e "SELECT USER() AS 'Current User', CURRENT_USER() AS 'Effective User';"
    
    # If a database is selected, also show privileges
    if [[ -n "$Database" ]]; then
      echo
      echo "Privileges for current user:"
      echo "--------------------------"
      
      local query_privs
      query_privs="SHOW GRANTS FOR CURRENT_USER();"
      
      mysql_exec --table -e "$query_privs"
        
      # Additional database-specific privileges if available
      if mysql_exec information_schema -e "SELECT 1 FROM TABLES WHERE 1=0" &>/dev/null; then
        echo
        echo "Database-specific privileges for current user:"
        echo "------------------------------------------"
        
        mysql_exec --table -e "SELECT PRIVILEGE_TYPE, IS_GRANTABLE 
                    FROM information_schema.USER_PRIVILEGES 
                    WHERE GRANTEE LIKE CONCAT(\"'%\", SUBSTRING_INDEX(CURRENT_USER(), '@', 1), \"%'\") 
                    ORDER BY PRIVILEGE_TYPE;"
      fi
    fi
  fi
  
  return 0
}

# List MySQL users and their privileges
handle_cmd_users() {
  info "MySQL Users and Privileges:"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # First, get list of users
  local query_users="SELECT 
                     User, 
                     Host, 
                     IF(plugin='mysql_native_password','Native Password',
                       IF(plugin='caching_sha2_password','SHA-2 Password', plugin)) AS 'Auth Method',
                     Account_locked as 'Locked'
                   FROM mysql.user
                   ORDER BY User, Host;"
  
  # Then get global privileges
  local query_global_privs="SELECT 
                          User, 
                          Host,
                          CONCAT(
                            IF(Select_priv='Y','SELECT,',''),
                            IF(Insert_priv='Y','INSERT,',''),
                            IF(Update_priv='Y','UPDATE,',''),
                            IF(Delete_priv='Y','DELETE,',''),
                            IF(Create_priv='Y','CREATE,',''),
                            IF(Drop_priv='Y','DROP,',''),
                            IF(Grant_priv='Y','GRANT,',''),
                            IF(References_priv='Y','REFERENCES,',''),
                            IF(Index_priv='Y','INDEX,',''),
                            IF(Alter_priv='Y','ALTER,',''),
                            IF(Create_tmp_table_priv='Y','CREATE_TMP,',''),
                            IF(Lock_tables_priv='Y','LOCK TABLES,',''),
                            IF(Create_view_priv='Y','CREATE VIEW,',''),
                            IF(Show_view_priv='Y','SHOW VIEW,',''),
                            IF(Create_routine_priv='Y','CREATE ROUTINE,',''),
                            IF(Alter_routine_priv='Y','ALTER ROUTINE,',''),
                            IF(Execute_priv='Y','EXECUTE,',''),
                            IF(Super_priv='Y','SUPER,','')
                          ) AS 'Global Privileges'
                        FROM mysql.user
                        ORDER BY User, Host;"
  
  # Database-specific privileges query
  local query_db_privs="SELECT 
                       User, 
                       Host, 
                       Db,
                       CONCAT(
                         IF(Select_priv='Y','SELECT,',''),
                         IF(Insert_priv='Y','INSERT,',''),
                         IF(Update_priv='Y','UPDATE,',''),
                         IF(Delete_priv='Y','DELETE,',''),
                         IF(Create_priv='Y','CREATE,',''),
                         IF(Drop_priv='Y','DROP,',''),
                         IF(Grant_priv='Y','GRANT,',''),
                         IF(References_priv='Y','REFERENCES,',''),
                         IF(Index_priv='Y','INDEX,',''),
                         IF(Alter_priv='Y','ALTER,',''),
                         IF(Create_tmp_table_priv='Y','CREATE_TMP,',''),
                         IF(Lock_tables_priv='Y','LOCK TABLES,',''),
                         IF(Create_view_priv='Y','CREATE VIEW,',''),
                         IF(Show_view_priv='Y','SHOW VIEW,',''),
                         IF(Create_routine_priv='Y','CREATE ROUTINE,',''),
                         IF(Alter_routine_priv='Y','ALTER ROUTINE,',''),
                         IF(Execute_priv='Y','EXECUTE,','')
                       ) AS 'Database Privileges'
                     FROM mysql.db
                     ORDER BY User, Host, Db;"
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    # Create a temporary file for all output to avoid piping issues
    local users_file
    users_file=$(create_secure_tempfile "${SCRIPT_NAME}.users")
    
    {
      echo "MySQL Users:"
      echo "-----------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "$query_users"
      
      echo
      echo "Global Privileges:"
      echo "----------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "$query_global_privs"
      
      echo
      echo "Database-Specific Privileges:"
      echo "---------------------------"
      mysql --defaults-file="$PROFILE" --no-auto-rehash \
        --table -e "$query_db_privs"
      
      # If a database is selected, also show table privileges
      if [[ -n "$Database" ]]; then
        echo
        echo "Table Privileges for database ${Database@Q}:"
        echo "-------------------------------------"
        local query_table_privs
        query_table_privs="SELECT 
                         User, 
                         Host, 
                         Table_name,
                         CONCAT(
                           IF(Table_priv & 1,'SELECT,',''),
                           IF(Table_priv & 2,'INSERT,',''),
                           IF(Table_priv & 4,'UPDATE,',''),
                           IF(Table_priv & 8,'DELETE,',''),
                           IF(Table_priv & 16,'CREATE,',''),
                           IF(Table_priv & 32,'DROP,',''),
                           IF(Table_priv & 64,'GRANT,',''),
                           IF(Table_priv & 128,'REFERENCES,',''),
                           IF(Table_priv & 256,'INDEX,',''),
                           IF(Table_priv & 512,'ALTER,','')
                         ) AS 'Table Privileges'
                       FROM mysql.tables_priv
                       WHERE Db = $(escape_sql_value "$Database")
                       ORDER BY User, Host, Table_name;"
        
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_table_privs"
      fi
    } > "$users_file"
    
    # Use less on the file directly instead of piping
    less -RS "$users_file"
    
    # Clean up temp file
    rm -f "$users_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    echo "MySQL Users:"
    echo "-----------"
    mysql_exec --table -e "$query_users"
    
    echo
    echo "Global Privileges:"
    echo "----------------"
    mysql_exec --table -e "$query_global_privs"
    
    echo
    echo "Database-Specific Privileges:"
    echo "---------------------------"
    mysql_exec --table -e "$query_db_privs"
    
    # If a database is selected, also show table privileges
    if [[ -n "$Database" ]]; then
      echo
      echo "Table Privileges for database ${Database@Q}:"
      echo "-------------------------------------"
      local query_table_privs
      query_table_privs="SELECT 
                       User, 
                       Host, 
                       Table_name,
                       CONCAT(
                         IF(Table_priv & 1,'SELECT,',''),
                         IF(Table_priv & 2,'INSERT,',''),
                         IF(Table_priv & 4,'UPDATE,',''),
                         IF(Table_priv & 8,'DELETE,',''),
                         IF(Table_priv & 16,'CREATE,',''),
                         IF(Table_priv & 32,'DROP,',''),
                         IF(Table_priv & 64,'GRANT,',''),
                         IF(Table_priv & 128,'REFERENCES,',''),
                         IF(Table_priv & 256,'INDEX,',''),
                         IF(Table_priv & 512,'ALTER,','')
                       ) AS 'Table Privileges'
                     FROM mysql.tables_priv
                     WHERE Db = $(escape_sql_value "$Database")
                     ORDER BY User, Host, Table_name;"
      
      mysql_exec --table -e "$query_table_privs"
    fi
  fi
  
  info "Note: Some privileges might require additional permissions to view."
  return 0
}

# Show active MySQL processes
handle_cmd_processes() {
  info "Active MySQL Processes:"
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local proc_file
    proc_file=$(create_secure_tempfile "${SCRIPT_NAME}.procs")
    
    # Output to temp file
    mysql --defaults-file="$PROFILE" --no-auto-rehash \
      --table -e "SHOW FULL PROCESSLIST;" > "$proc_file"
    
    # Use less directly on the file
    less -RS "$proc_file"
    
    # Clean up
    rm -f "$proc_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    mysql_exec --table -e "SHOW FULL PROCESSLIST;"
  fi
  
  # Add option to kill a process
  info "To kill a process, use SQL: KILL <process_id>"
  
  return 0
}

# Display MySQL system variables
handle_cmd_variables() {
  local filter="$*"
  local query
  
  if [[ -n "$filter" ]]; then
    # If a filter is provided, use it to narrow down the variables
    info "MySQL System Variables (filtered by ${filter@Q}):"
    query="SHOW VARIABLES WHERE Variable_name LIKE '%$(mysql_exec -e "SELECT $(escape_sql_value "$filter");" | tr -d "'")%';"
  else
    # Otherwise show all variables
    info "MySQL System Variables:"
    query="SHOW VARIABLES;"
  fi
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  # Execute with appropriate formatting and paging
  if (( use_pager )); then
    local vars_file
    vars_file=$(create_secure_tempfile "${SCRIPT_NAME}.vars")
    
    # Output to temp file
    mysql --defaults-file="$PROFILE" --no-auto-rehash \
      --table -e "$query" > "$vars_file"
    
    # Use less directly on the file
    less -RS "$vars_file"
    
    # Clean up
    rm -f "$vars_file"
    
    # Reset terminal after using less
    stty sane 2>/dev/null || true
  else
    # Direct output without pager
    mysql_exec --table -e "$query"
  fi
  
  info "Filter variables with: /variables <filter>"
  
  return 0
}

# Export query results to a file
handle_cmd_export() {
  require_table || return 1
  
  # Parse arguments safely
  local filename=''
  local format='csv'  # Default format
  local include_headers=1
  local delimiter=','
  
  # Create a safely quoted version of the arguments for processing
  local args=()
  for arg in "$@"; do
    args+=("$arg")
  done
  
  # Check for format flag first
  for ((i=0; i<${#args[@]}; i+=1)); do
    if [[ "${args[$i]}" == "--format" ]]; then
      if ((i+1 < ${#args[@]})); then
        format="${args[$((i+1))]}"
        # Remove these arguments
        args=("${args[@]:0:$i}" "${args[@]:$((i+2))}")
        break
      fi
    fi
  done

  # Check for headers flag
  for ((i=0; i<${#args[@]}; i+=1)); do
    if [[ "${args[$i]}" == "--no-headers" ]]; then
      include_headers=0
      # Remove this argument
      args=("${args[@]:0:$i}" "${args[@]:$((i+1))}")
      break
    fi
  done

  # Check for delimiter flag
  for ((i=0; i<${#args[@]}; i+=1)); do
    if [[ "${args[$i]}" == "--delimiter" ]]; then
      if ((i+1 < ${#args[@]})); then
        delimiter="${args[$((i+1))]}"
        # Remove these arguments
        args=("${args[@]:0:$i}" "${args[@]:$((i+2))}")
        break
      fi
    fi
  done
  
  # First argument (if any) is now the filename
  if ((${#args[@]})); then
    filename="${args[0]}"
  fi
  
  # Generate default filename if not provided
  if [[ -z "$filename" ]]; then
    local current_time
    current_time=$(date +"%Y%m%d_%H%M%S")
    filename="${Database}_${DataTable}_${current_time}.${format}"
  fi
  
  # Normalize format to lowercase and validate
  format="${format,,}"
  case "$format" in
    csv|sql|json)
      ;;
    *)
      error "Unsupported format: $format. Use csv, sql, or json."
      return 1
      ;;
  esac
  
  # Build the SQL query
  local sql='SELECT '

  # Handle column selection
  if [[ "${SelectedColumns[*]}" == '*' ]]; then
    sql+='*'
  else
    local quoted_cols=()
    local col
    for col in "${SelectedColumns[@]}"; do
      # Quote each column identifier
      quoted_cols+=("$(quote_ident "$col")")
    done
    sql+=$(IFS=,; echo "${quoted_cols[*]}")
  fi
  
  # Add table name (safely quoted)
  sql+=" FROM $(quote_ident "$DataTable")"
  
  # Add WHERE clause if specified
  if [[ -n "$WhereClause" ]]; then
    sql+=" WHERE $WhereClause"
  fi
  
  # Add ORDER BY if specified
  if [[ -n "$OrderClause" ]]; then
    local order_parts
    IFS=',' read -ra order_parts <<< "$OrderClause"
    local quoted_order_parts=()
    local part
    for part in "${order_parts[@]}"; do
      quoted_order_parts+=("$(quote_ident "$(trim "$part")")")
    done
    sql+=" ORDER BY $(IFS=,; echo "${quoted_order_parts[*]}") $OrderDirection"
  fi
  
  # Add LIMIT if specified
  if [[ -n "$LimitClause" ]]; then
    if [[ "$LimitClause" =~ ^[0-9]+$ ]]; then
      sql+=" LIMIT $LimitClause"
    else
      error "Invalid LIMIT value: $LimitClause (must be numeric)"
      return 1
    fi
  fi
  
  info "Exporting data from '$Database.$DataTable' to ${filename@Q} in $format format..."
  
  # Export based on format
  case "$format" in
    csv)
      # Export as CSV
      local mysql_args=''
      if (( include_headers )); then
        mysql_args+=" -B"  # Include column names as first row
      else
        mysql_args+=" -N"  # Skip column names
      fi
      
      # Need to handle custom delimiter
      if [[ "$delimiter" != "," ]]; then
        local temp_file
        temp_file=$(create_secure_tempfile "${SCRIPT_NAME}.export")
        # shellcheck disable=SC2086
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" ${mysql_args} -e "$sql" > "$temp_file"
        if [[ "$delimiter" == "tab" || "$delimiter" == "\t" ]]; then
          # Special case for tab-delimited
          tr '\t' '\t' < "$temp_file" > "$filename"
        else
          # Replace default delimiter with custom one
          tr '\t' "$delimiter" < "$temp_file" > "$filename"
        fi
        rm -f "$temp_file"
      else
        # Standard CSV with comma delimiter
        # shellcheck disable=SC2086
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" ${mysql_args} -e "$sql" | \
          sed 's/\t/,/g' > "$filename"
      fi
      ;;
      
    sql)
      # Export as SQL INSERT statements
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
        -e "SELECT * FROM ($sql) AS export_query INTO OUTFILE '$filename' 
           FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\"'
           LINES TERMINATED BY '\n';" || {
        # If the direct outfile fails (due to permissions), use mysqldump
        mysqldump --defaults-file="$PROFILE" --no-create-info --no-create-db \
          --complete-insert --extended-insert=FALSE --skip-triggers --compact \
          "$Database" "$DataTable" --where="${WhereClause:-1}" > "$filename" || {
          error "Export failed. Check permissions or try a different path."
          return 1
        }
      }
      ;;
      
    json)
      # Export as JSON
      # Use a temporary file for intermediate results
      local temp_file
      temp_file=$(create_secure_tempfile "${SCRIPT_NAME}.export")
      
      # Get column names first for JSON object keys
      local columns_list
      columns_list=$(mysql_exec "$Database" -Nse "SHOW COLUMNS FROM $(quote_ident "$DataTable") WHERE 1;") || { 
        error "Could not retrieve columns for '$Database.$DataTable'."
        rm -f "$temp_file"
        return 1
      }
      
      # Extract just the column names
      local columns=()
      mapfile -t columns < <(echo "$columns_list" | awk '{print $1}')
      
      # Modify SQL to output in a format we can convert to JSON
      mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" -N -e "$sql" > "$temp_file"
      
      # Convert tab-delimited output to JSON
      echo "[" > "$filename"
      local line_count=0
      while IFS=$'\t' read -r -a values; do
        if ((line_count)); then
          echo "," >> "$filename"
        fi
        echo -n "  {" >> "$filename"
        
        local -i field_count=0
        for i in "${!values[@]}"; do
          if ((i < ${#columns[@]})); then
            if ((field_count)); then
              echo -n "," >> "$filename"
            fi
            # Properly escape JSON field value
            local escaped_value="${values[i]//\\/\\\\}"  # Escape backslashes
            escaped_value="${escaped_value//\"/\\\"}"    # Escape quotes
            escaped_value="${escaped_value//$'\n'/\\n}"  # Escape newlines
            echo -n "\"${columns[i]}\":\"$escaped_value\"" >> "$filename"
            field_count+=1
          fi
        done

        echo -n '}' >> "$filename"
        line_count+=1
      done < "$temp_file"
      echo -e "\n]" >> "$filename"
      
      rm -f "$temp_file"
      ;;
  esac
  
  # Check if the file was created successfully
  if [[ -f "$filename" ]]; then
    success "Export completed to ${filename@Q}"
    info "Exported $(wc -l < "$filename") rows."
    info "File size: $(du -h "$filename" | cut -f1)"
  else
    error "Export failed. File was not created."
    return 1
  fi
  
  return 0
}

# Show database/table statistics and metrics
handle_cmd_stats() {
  require_database || return 1
  
  # Check if less is available for paging
  local use_pager=0
  if command -v less >/dev/null; then
    use_pager=1
  fi
  
  if [[ -n "$DataTable" ]]; then
    # Table-specific statistics
    info "Statistics for table '$Database.$DataTable':"
    
    # Get basic stats
    local query_basic
    query_basic="SHOW TABLE STATUS LIKE $(escape_sql_value "$DataTable");"
    
    # Get index stats
    local query_indexes
    query_indexes="SHOW INDEX FROM $(quote_ident "$DataTable");"
    
    # Get column stats
    local query_columns
    query_columns="SELECT 
                 COLUMN_NAME, 
                 DATA_TYPE,
                 CHARACTER_MAXIMUM_LENGTH as 'Max Length',
                 IS_NULLABLE as 'Nullable',
                 COLUMN_DEFAULT as 'Default',
                 EXTRA
               FROM information_schema.COLUMNS
               WHERE TABLE_SCHEMA = $(escape_sql_value "$Database")
               AND TABLE_NAME = $(escape_sql_value "$DataTable")
               ORDER BY ORDINAL_POSITION;"
    
    # Table cardinality distribution
    local query_card
    query_card="ANALYZE TABLE $(quote_ident "$DataTable");"
    
    # Execute with appropriate formatting and paging
    if (( use_pager )); then
      # Create a temporary file for all output to avoid piping issues
      local stats_file
      stats_file=$(create_secure_tempfile "${SCRIPT_NAME}.stats")
      
      {
        echo "Table Statistics for '$Database.$DataTable':"
        echo "----------------------------------------"
        echo
        echo "Basic Information:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query_basic"
        
        echo
        echo "Column Statistics:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query_columns"
        
        echo
        echo "Index Statistics:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query_indexes"
        
        echo
        echo "Row Counts:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          -e "SELECT COUNT(*) as 'Total Rows' FROM $(quote_ident "$DataTable");"
        
        # Additional stats depending on the MySQL version
        echo
        echo "Index Cardinality:"
        mysql --defaults-file="$PROFILE" --no-auto-rehash "$Database" \
          --table -e "$query_card"
      } > "$stats_file"
      
      # Use less on the file directly instead of piping
      less -RS "$stats_file"
      
      # Clean up temp file
      rm -f "$stats_file"
      
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    else
      # Direct output without pager
      echo "Table Statistics for '$Database.$DataTable':"
      echo "----------------------------------------"
      echo
      echo "Basic Information:"
      mysql_exec "$Database" --table -e "$query_basic"
      
      echo
      echo "Column Statistics:"
      mysql_exec "$Database" --table -e "$query_columns"
      
      echo
      echo "Index Statistics:"
      mysql_exec "$Database" --table -e "$query_indexes"
      
      echo
      echo "Row Counts:"
      mysql_exec "$Database" -e "SELECT COUNT(*) as 'Total Rows' FROM $(quote_ident "$DataTable");"
      
      # Additional stats depending on the MySQL version
      echo
      echo "Index Cardinality:"
      mysql_exec "$Database" --table -e "$query_card"
    fi
  else
    # Database-wide statistics
    info "Statistics for database ${Database@Q}:"
    
    # Get tables stats
    local query_tables
    query_tables="SELECT 
                TABLE_NAME as 'Table',
                TABLE_ROWS as 'Rows',
                ROUND(DATA_LENGTH/1024/1024, 2) as 'Data Size (MB)',
                ROUND(INDEX_LENGTH/1024/1024, 2) as 'Index Size (MB)',
                ROUND((DATA_LENGTH+INDEX_LENGTH)/1024/1024, 2) as 'Total Size (MB)',
                TABLE_COLLATION as 'Collation',
                ENGINE as 'Engine',
                CREATE_TIME as 'Created',
                UPDATE_TIME as 'Updated'
              FROM information_schema.TABLES
              WHERE TABLE_SCHEMA = $(escape_sql_value "$Database")
              ORDER BY (DATA_LENGTH+INDEX_LENGTH) DESC;"
    
    # Get database size
    local query_size
    query_size="SELECT 
              COUNT(*) as 'Tables',
              ROUND(SUM(DATA_LENGTH)/1024/1024, 2) as 'Data Size (MB)',
              ROUND(SUM(INDEX_LENGTH)/1024/1024, 2) as 'Index Size (MB)',
              ROUND(SUM(DATA_LENGTH+INDEX_LENGTH)/1024/1024, 2) as 'Total Size (MB)'
            FROM information_schema.TABLES
            WHERE TABLE_SCHEMA = $(escape_sql_value "$Database");"
    
    # Execute with appropriate formatting and paging
    if (( use_pager )); then
      # Create a temporary file for all output to avoid piping issues
      local stats_file
      stats_file=$(create_secure_tempfile "${SCRIPT_NAME}.stats")
      
      {
        echo "Database Statistics for ${Database@Q}:"
        echo "---------------------------------"
        echo
        echo 'Database Size Summary:'
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_size"
        
        echo
        echo 'Table Statistics (sorted by size):'
        mysql --defaults-file="$PROFILE" --no-auto-rehash \
          --table -e "$query_tables"
      } > "$stats_file"
      
      # Use less on the file directly instead of piping
      less -RS "$stats_file"
      
      # Clean up temp file
      rm -f "$stats_file"
      
      # Reset terminal after using less
      stty sane 2>/dev/null || true
    else
      # Direct output without pager
      echo "Database Statistics for ${Database@Q}:"
      echo '---------------------------------'
      echo
      echo 'Database Size Summary:'
      mysql_exec --table -e "$query_size"
      
      echo
      echo 'Table Statistics (sorted by size):'
      mysql_exec --table -e "$query_tables"
    fi
  fi
  
  return 0
}

#=============================================================================
# Main Execution Logic
# Handles startup, arguments, and interactive command loop
#=============================================================================
# The main function is the entry point for the dbh utility and orchestrates
# the entire application flow. It handles:
#
# 1. Configuration loading and initialization
# 2. Command-line argument parsing
# 3. MySQL profile validation and connection checking
# 4. Initial database/table context setup
# 5. Command history management
# 6. Interactive command loop with input processing
# 7. Command dispatching to appropriate handlers
#
# The interactive loop processes user input and dispatches commands based on
# the input's first character:
# - / → Slash command (database operations)
# - ! → Bang command (shell operations)
# - Other → Direct SQL execution
#
# Security is enforced through proper parameter handling, error checking,
# and the use of secure helper functions for all operations.
#=============================================================================
main() {
  # --- Configuration & Initialization ---
  local -i InteractiveMode=1
  
  # Load user configuration from ~/.config/dbh/config
  load_config
  
  while (($#)); do
    case $1 in
      -p|--profile)
        noarg "$@"; shift
        PROFILE=$1
        ;;
      -V|--version)
        echo "$SCRIPT_NAME $VERSION"
        exit 0
        ;;
      -v|--verbose)
        VERBOSE+=1
        ;;
      -q|--quiet)
        VERBOSE=0
        ;;
      -h|--help)
        usage 0
        ;;
      # Handle combined short options (e.g., -vq)
      -[pvqhV]*)
        # Loop through each character and add as separate option
        local -- char
        for char in $(echo "${1:1}" | grep -o .); do
          set -- "$@" "-$char"
        done
        shift # Remove the original combined option
        continue # Restart the loop to process the new options
        ;;
      --)
        shift
        break
        ;;
      -*)
        usage 22 "Invalid option ${1@Q}"
        ;;
      *)
        # Positional arguments
        if [[ -z "$Database" ]]; then
          Database=$1
        elif [[ -z "$DataTable" ]]; then
          DataTable=$1
        else
          usage 22 "Too many arguments ${1@Q}"
        fi
        ;;
    esac
    shift
  done
  
  # Process any remaining arguments
  while (($#)); do
    if [[ -z "$Database" ]]; then
      Database=$1
    elif [[ -z "$DataTable" ]]; then
      DataTable=$1
    else
      usage 22 "Too many arguments ${1@Q}"
    fi
    shift
  done

  # --- Profile Validation & Connection Check ---
  # Set default profile if none specified
  if [[ -z "$PROFILE" ]]; then
    PROFILE=$Profile_Default
  fi
  
  # Store original path for error messages
  local -- profile_path="$PROFILE"
  
  # Try relative path if profile not found and path isn't absolute
  if ! [[ -f "$PROFILE" ]] && [[ "$PROFILE" != /* ]]; then
    # Expand tilde if present
    if [[ "$PROFILE" == \~* ]]; then
      PROFILE="${HOME}${PROFILE:1}"
      debug "Expanded tilde in profile path ${PROFILE@Q}"
    # Try relative to program directory
    elif [[ -f "$SCRIPT_DIR"/"$PROFILE" ]]; then
      PROFILE="$SCRIPT_DIR"/"$PROFILE"
      debug "Found profile at relative path ${PROFILE@Q}"
    fi
  fi

  # Find the canonical profile path
  local -- resolved_profile=''
  local -i resolve_status=1 # Default to failure
  
  # Attempt path resolution with realpath or readlink
  if command -v realpath >/dev/null; then
    # Try realpath first (preferred)
    resolved_profile=$(realpath -m -q -- "$PROFILE" 2>/dev/null)
    resolve_status=$?
    
    if ((resolve_status)); then
      warn "Could not resolve profile path with realpath ${profile_path@Q}"
    else
      debug "Resolved profile path using realpath ${resolved_profile@Q}"
    fi
  fi

  # Fall back to readlink if realpath failed or wasn't available
  if ((resolve_status)) && command -v readlink >/dev/null; then
    debug 'Attempting to resolve profile path with readlink'
    resolved_profile=$(readlink -m -- "$PROFILE" 2>/dev/null)
    resolve_status=$?
    
    if ((resolve_status)); then
      warn "Could not resolve profile path with readlink ${profile_path@Q}"
    else
      debug "Resolved profile path using readlink ${resolved_profile@Q}"
    fi
  fi

  # Last resort: use the original path if it exists
  if ((resolve_status)); then
    if [[ -f "$PROFILE" ]]; then
      warn "Using unresolved profile path ${PROFILE@Q}"
      resolved_profile=$PROFILE
      resolve_status=0
    else
      die 1 "Could not find or access profile at path ${profile_path@Q}"
    fi
  fi
  
  # Use the resolved path
  PROFILE="$resolved_profile"
  
  # Final check: Does the resolved path exist as a file?
  if [[ ! -f "$PROFILE" ]]; then
    die 2 "Profile file not found ${PROFILE@Q} (original: ${profile_path@Q})"
  fi
  
  # Check if profile is readable
  if [[ ! -r "$PROFILE" ]]; then
    die 2 "Profile file exists but is not readable ${PROFILE@Q}"
  fi
  
  debug "Using MySQL profile ${PROFILE@Q}"

  # --- Prerequisite Checks ---
  command -v mysql >/dev/null || die 1 "MySQL client 'mysql' not found."
  ((VERBOSE)) && info "Checking initial connection..."
  local init_check_status=0
  mysql_exec -e 'SELECT 1;' >/dev/null || init_check_status=$? # Suppress "1" output
  if ((init_check_status)); then die 1 "Initial connection failed using profile ${PROFILE@Q}. Check errors."; fi
  ((VERBOSE)) && success "Connection successful." && info "Using profile ${PROFILE@Q}"

  # --- Load command history ---
  load_history

  # --- Initial Context Setup ---
  if [[ -n "$Database" ]]; then
      # Use || true to prevent exit if initial context setting fails
      set_database_context "$Database" || true
      # Only try setting table if DB was set successfully
      if [[ -n "$Database" && -n "$DataTable" ]]; then
          set_table_context "$DataTable" || true
      fi
  fi

  # --- Startup Behavior: Ensure Database is Selected ---
  if (( InteractiveMode )) && [[ -z "$Database" ]]; then
    info 'No initial database selected. Please choose one:'
    handle_cmd_databases || true # Prevent exit if user cancels selection
    # If still no DB after menu (user cancelled), exit cleanly.
    [[ -n "$Database" ]] || { info "No database selected. Exiting."; exit 0; }
  fi

  # --- Interactive Mode Loop ---
  info "Starting interactive mode. Type '/help' for commands, '/q' to quit."
  local input raw_cmd cmd args
  
  # Detect non-interactive mode
  if ! [[ -t 0 ]]; then
    info 'Detected non-interactive mode (input from pipe)'
  fi
  
  # Start the interactive loop
  while :; do
      # Check if read returns non-zero (EOF)
      prompt "$PromptPrefix> "
      if ! read -e input; then 
        info 'EOF detected. Exiting.'
        echo
        break
      fi
      input=$(trim "$input")
      [[ -n "$input" ]] || continue
      
      # Add to history (skip exit/history/config commands)
      if [[ "$input" != '/history' && "$input" != '/config' && "$input" != '/q' && "$input" != '/quit' && "$input" != '/exit' ]]; then
        CommandHistory+=("$input")
        history -s "$input" 2>/dev/null || true
        history -w "$HISTFILE" 2>/dev/null || true
      fi
    # First check for history recall with !number
    if [[ "$input" =~ ^![0-9]+$ ]]; then
      # Extract the history number
      local -- history_num=${input:1}
      # Check if it's in our tracked history
      if ((history_num > 0 && history_num <= ${#CommandHistory[@]})); then
        # Get the command from our history (adjust for 0-based array)
        local -- history_cmd="${CommandHistory[$((history_num-1))]}"
        info "Recalling command: $history_cmd"
        # Set the input to the recalled command and continue processing
        input=$history_cmd
        # Add to history and continue with normal processing
        CommandHistory+=("$input")
      else
        # Let the shell's built-in history expansion handle it
        info 'Using shell history recall'
        # We'll fall through to shell command handling (!command)
      fi
    fi
    
    # Process input based on first character
    if [[ "$input" =~ ^/ ]]; then
      # Handle slash commands (/command)
      raw_cmd=${input:1}
      if [[ "$raw_cmd" =~ ^([a-zA-Z0-9_?]+)[[:space:]]+(.*)$ ]]; then 
        cmd=${BASH_REMATCH[1]}
        args=${BASH_REMATCH[2]}
      elif [[ "$raw_cmd" =~ ^([a-zA-Z0-9_?]+)$ ]]; then 
        cmd=$raw_cmd
        args=''
      elif [[ "$raw_cmd" =~ ^(\.\.|0|back)$ ]]; then 
        cmd=$raw_cmd
        args=''
      elif [[ -z "$raw_cmd" ]]; then 
        continue
      else
        error "Invalid command format ${input@Q}"
        continue
      fi
      
      # Execute command handlers, append '|| true' to prevent set -e exit
      case "$cmd" in
        help|\?)        handle_cmd_help || true ;;
        databases)      handle_cmd_databases || true ;;
        database)       handle_cmd_database "$args" || true ;;
        tables)         handle_cmd_tables || true ;;
        table)          handle_cmd_table "$args" || true ;;
        columns)        handle_cmd_columns "$args" || true ;;
        where)          handle_cmd_where "$args" || true ;;
        order)          handle_cmd_order "$args" || true ;;
        asc)            handle_cmd_asc_desc "asc" || true ;;
        # DESC is now only for sort order
        desc)           handle_cmd_asc_desc "desc" || true ;;
        limit)          handle_cmd_limit "$args" || true ;;
        select)         handle_cmd_select || true ;;
        state)          show_select_state || true ;;
        # These commands require a table to be selected
        describe)       handle_cmd_desc || true ;; # Table structure command
        structure)      handle_cmd_structure "$args" || true ;; # Detailed column information
        status)         handle_cmd_status || true ;;
        create)         handle_cmd_create || true ;;
        count)          handle_cmd_count || true ;;
        # New table exploration commands
        sample)         handle_cmd_sample "$args" || true ;;
        primary-key)    handle_cmd_primary_key || true ;;
        primary_key)    handle_cmd_primary_key || true ;; # Alternative syntax
        indexes)        handle_cmd_indexes || true ;;
        find)           handle_cmd_find "$args" || true ;;
        # Database schema and advanced features
        schema)         handle_cmd_schema "$args" || true ;;
        foreign-keys)   handle_cmd_foreign_keys || true ;;
        foreign_keys)   handle_cmd_foreign_keys || true ;; # Alternative syntax
        backup)         handle_cmd_backup "$args" || true ;;
        charset)        handle_cmd_charset || true ;;
        engines)        handle_cmd_engines || true ;;
        # Administration and performance
        whoami)         handle_cmd_whoami || true ;;
        whois)          handle_cmd_whois "$args" || true ;;
        users)          handle_cmd_users || true ;;
        processes)      handle_cmd_processes || true ;;
        variables)      handle_cmd_variables "$args" || true ;;
        export)         handle_cmd_export "$args" || true ;;
        stats)          handle_cmd_stats || true ;;
        # General commands
        history)        handle_cmd_history "$args" || true ;;
        config)         handle_cmd_config "$args" || true ;;
        sql)            handle_cmd_sql "$args" || true ;;
        prompt)         handle_cmd_prompt || true ;;
        # Navigation
        ..|0|back)      go_back_context || true ;;
        q|quit|exit)    info 'Exiting.'; break ;; # Exit loop cleanly
        *)              error "Unknown command '/$cmd'. Type '/help' for options." ;;
      esac
    elif [[ "$input" =~ ^! ]]; then
      # Handle shell commands (!command)
      if [[ "$input" == '!' ]]; then
        # Just '!' launches interactive shell
        handle_shell_command || true
      else
        # '!command' or '!shell command' executes command
        if [[ "$input" =~ ^!shell[[:space:]]+(.*)$ ]]; then
          # '!shell command' syntax
          handle_shell_command "${BASH_REMATCH[1]}" || true
        else
          # '!command' syntax - remove the leading ! and pass rest as command
          handle_shell_command "${input:1}" || true
        fi
      fi
    else
      # Treat as direct SQL command if a database is selected
      if [[ -n "$Database" ]]; then
        info "Executing SQL in ${Database@Q}: $input"
        mysql_run_display "$Database" --table -e "$input" || true
      else
        error 'No database selected. Select a database with /database first, or use / or ! commands.'
        info "Type '/help' for available commands or '/databases' to select a database."
      fi
    fi
  done # End while loop
  success 'Exiting.'
}

# --- Script Entry Point ---
main "$@"
#fin
